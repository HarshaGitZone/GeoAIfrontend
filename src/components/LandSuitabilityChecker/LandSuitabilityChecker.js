import React, { useState, useEffect, useCallback, useRef, memo } from "react";
// import { Marker, useMap, useMapEvents } from "react-leaflet";
import { MapContainer, TileLayer, Marker, useMap, useMapEvents, Popup } from "react-leaflet";
import FactorBar from "../FactorBar/FactorBar";
import SideBar from "../SideBar/SideBar";
import "leaflet/dist/leaflet.css";
import L from "leaflet";
import ProMap from '../ProMap/ProMap';
import "./LandSuitabilityChecker.css";
import TopNav from "../TopNav/TopNav";
import RadarChart from "../RadarChart/RadarChart"; 
import WeatherCard from '../Weather/WeatherCard';
import HazardsCard from '../HazardsCard/HazardsCard';
import SnapshotGeo from '../SnapshotGeo/SnapshotGeo';
import DigitalTwin from '../DigitalTwin/DigitalTwin';
// import ReactMarkdown from 'react-markdown';
// import remarkGfm from 'remark-gfm';
import GeoGPT from '../GeoGPT/GeoGPT';
import AudioLandscape from "../AudioLandscape/AudioLandscape";
import { API_BASE } from '../../config/api';

// Fix Leaflet marker icons

delete L.Icon.Default.prototype._getIconUrl;

L.Icon.Default.mergeOptions({

  iconRetinaUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png",

  iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",

  shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",

});

// const spectralLayers = {

//   standard: null,

//   ndvi: "https://services.sentinel-hub.com/ogc/wms/YOUR_API_KEY?LAYER=NDVI&...",

//   thermal: "https://services.sentinel-hub.com/ogc/wms/YOUR_API_KEY?LAYER=THERMAL&...",

//   hydrology: "https://your-backend-api.com/hydrology/{z}/{x}/{y}.png"

// };

const spectralLayers = {

  standard: null,



  ndvi: "https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-2020_3857/default/g/{z}/{y}/{x}.jpg",



  thermal: "https://tiles.maps.eox.at/wmts/1.0.0/terrain-light_3857/default/g/{z}/{y}/{x}.jpg",



  hydrology: "https://tiles.maps.eox.at/wmts/1.0.0/hydrography_3857/default/g/{z}/{y}/{x}.jpg"

};



const varieties = {

  streets: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",

  satellite: "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",

  hybrid: "https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}",

  terrain: "https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}",

  roads: "https://mt1.google.com/vt/lyrs=h&x={x}/{y}&z={z}",

  dark: "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",

  light: "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",

  voyager: "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png",

  topo: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",

  watercolor: "https://stamen-tiles.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.jpg"

};



/** * UTILITY: Moved outside to avoid unnecessary dependency warnings 

 */

const isNearbyDevice = (lat1, lng1, deviceLoc) => {

  if (!deviceLoc || !deviceLoc.lat || !deviceLoc.lng) return false;

  return (

    parseFloat(lat1).toFixed(4) === deviceLoc.lat &&

    parseFloat(lng1).toFixed(4) === deviceLoc.lng

  );

};



// --- DYNAMIC INFERENCE ENGINE ---

// const getSitePotential = (factors,activeSpectral) => {

//   const potentials = [];

//   const f = factors;



//   const hazards = Object.entries(f)

//     .filter(([key, val]) => (key === 'flood' || key === 'landslide' || key === 'pollution') && val < 45)

//     .map(([key]) => key.toUpperCase());



//   if (hazards.length > 0) {

//     potentials.push({

//       type: "Risk",

//       label: "Environmental Constraints",

//       class: "pot-red",

//       icon: "‚ö†Ô∏è",

//       reason: `Warning: This site faces critical risks due to low safety scores in ${hazards.join(" & ")}. Development may require expensive mitigation or be restricted to conservation.`

//     });

//   }



//   if (f.flood > 50 && f.landslide > 50 && f.pollution > 40) {

//     const strength = f.pollution > 70 ? "pristine air quality" : "stable terrain";

//     potentials.push({

//       type: "Residential",

//       label: "Residential Potential",

//       class: "pot-green",

//       icon: "üè†",

//       reason: `Recommended for housing due to ${strength}. The site provides a safe foundation with manageable environmental risks.`

//     });

//   }



//   if (f.soil > 60 || f.rainfall > 60) {

//     const leadFactor = f.soil > f.rainfall ? "High Soil Nutrient Density" : "Abundant Rainfall Patterns";

//     potentials.push({

//       type: "Agricultural",

//       label: "Agricultural Utility",

//       class: "pot-blue",

//       icon: "üöú",

//       reason: `Viable for farming driven by ${leadFactor}. This land can support sustainable crop cycles if water management is maintained.`

//     });

//   }



//   if (f.proximity > 60 && f.landuse > 40) {

//     potentials.push({

//       type: "Industrial",

//       label: "Logistics & Industry",

//       class: "pot-purple",

//       icon: "üè≠",

//       reason: `Strategic for commercial use because it ranks top 20% in Infrastructure Proximity (${f.proximity.toFixed(0)}%). Ideal for warehouses or manufacturing.`

//     });

//   }

//   // 3Ô∏è‚É£ HYDROLOGY INTELLIGENCE: Connect Flow to Flood Risk

//   if (activeSpectral === "hydrology" && f.flood < 50) {

//     potentials.push({

//       type: "Risk",

//       label: "Hydrological Trap",

//       class: "pot-red",

//       icon: "üåä",

//       reason: "Overlay reveals physics-based water accumulation at this coordinate. Stormwater will likely pool here due to the terrain slope."

//     });

//   }



//   // 2Ô∏è‚É£ THERMAL INTELLIGENCE: Residential Livability

//   if (activeSpectral === "thermal" && f.pollution < 60) {

//     potentials.push({

//       type: "Climate",

//       label: "Urban Heat Island",

//       class: "pot-blue",

//       icon: "üå°Ô∏è",

//       reason: "Site absorbs high solar radiation. Residential planning should include green roofing to mitigate cooling costs."

//     });

//   }

//   return potentials;

// };

const getSitePotential = (factors, activeSpectral) => {

  const potentials = [];



  if (!factors) return potentials;



  // --------------------------------------------------

  // NORMALIZE FACTORS (single source of truth)

  // --------------------------------------------------

  const f = {

    // Hydrology (3)

    flood: factors?.hydrology?.flood?.value ?? 50,

    water: factors?.hydrology?.water?.value ?? 50,

    drainage: factors?.hydrology?.drainage?.value ?? 50,

    // Environmental (3)

    pollution: factors?.environmental?.pollution?.value ?? 50,

    soil: factors?.environmental?.soil?.value ?? 50,

    vegetation: factors?.environmental?.vegetation?.value ?? 50,

    // Climatic (3)

    rainfall: factors?.climatic?.rainfall?.value ?? 50,

    thermal: factors?.climatic?.thermal?.value ?? 50,

    heatIntensity: factors?.climatic?.intensity?.value ?? 50,

    // Socio-economic (3)

    infrastructure: factors?.socio_econ?.infrastructure?.value ?? 50,

    landuse: factors?.socio_econ?.landuse?.value ?? 50,

    population: factors?.socio_econ?.population?.value ?? 50,

    // Physical (2)

    slope: factors?.physical?.slope?.value ?? 50,

    elevation: factors?.physical?.elevation?.value ?? 50,

  };



  // --------------------------------------------------

  // 1Ô∏è‚É£ HARD RISK DETECTION (RESTRICTION ZONE)

  // --------------------------------------------------

  const hazards = [];



  if (f.flood < 40) hazards.push("FLOOD RISK");

  if (f.pollution < 35) hazards.push("AIR QUALITY");

  if ((f.slope ?? 100) < 35) hazards.push("STEEP TERRAIN");



  if (f.drainage < 40) hazards.push("POOR DRAINAGE");

  if (f.heatIntensity > 70) hazards.push("HIGH HEAT STRESS");



  if (hazards.length > 0) {

    const detail = [];

    if (f.flood < 40) detail.push(`flood safety ${f.flood.toFixed(0)}/100`);

    if (f.pollution < 35) detail.push(`air quality ${f.pollution.toFixed(0)}/100`);

    if ((f.slope ?? 100) < 35) detail.push(`slope suitability ${(f.slope ?? 0).toFixed(0)}/100 (steep)`);

    if (f.drainage < 40) detail.push(`drainage ${f.drainage.toFixed(0)}/100`);

    if (f.heatIntensity > 70) detail.push(`heat stress ${f.heatIntensity.toFixed(0)}/100`);

    potentials.push({

      type: "Risk",

      label: "Development Constraints",

      class: "pot-red",

      icon: "‚ö†Ô∏è",

      reason: `Critical limitations: ${hazards.join(" & ")}. ${detail.length ? `Numericals: ${detail.join("; ")}. ` : ""}Construction may require advanced mitigation or be restricted to conservation or low-impact usage.`,

    });

  }



  // --------------------------------------------------

  // 2Ô∏è‚É£ RESIDENTIAL SUITABILITY

  // --------------------------------------------------

  if (

    f.flood > 55 &&

    f.pollution > 50 &&

    f.thermal > 55 &&

    f.infrastructure > 50 &&

    (f.slope ?? 50) > 70

  ) {

    const comfortDriver =

      f.pollution > 70

        ? "clean air quality"

        : f.thermal > 70

        ? "comfortable climate conditions"

        : "stable terrain conditions";



    potentials.push({

      type: "Residential",

      label: "Residential Development",

      class: "pot-green",

      icon: "üè†",

      reason: `Well-suited for housing due to ${comfortDriver}, manageable flood exposure, and good infrastructure accessibility.`,

    });

  }



  // --------------------------------------------------

  // 3Ô∏è‚É£ AGRICULTURAL POTENTIAL (only when vegetation supports it)

  // --------------------------------------------------

  const veg = f.vegetation ?? 50;

  if (

    veg >= 45 &&

    ((f.soil > 60 && f.rainfall > 50) || (f.soil > 55 && f.water > 60))

  ) {

    const agriDriver =

      f.soil > f.rainfall

        ? "high soil fertility"

        : "reliable rainfall and water availability";



    potentials.push({

      type: "Agricultural",

      label: "Agricultural Suitability",

      class: "pot-blue",

      icon: "üöú",

      reason: `Favorable for farming driven by ${agriDriver}. Vegetation index ${veg.toFixed(0)}/100 supports crop potential. Suitable for sustained crop cycles with moderate water management.`,

    });

  }



  // --------------------------------------------------

  // 4Ô∏è‚É£ INDUSTRIAL / LOGISTICS POTENTIAL

  // --------------------------------------------------

  if (

    f.infrastructure > 65 &&

    f.landuse > 45 &&

    f.flood > 50 &&

    f.pollution > 40

  ) {

    potentials.push({

      type: "Industrial",

      label: "Logistics & Industrial Use",

      class: "pot-purple",

      icon: "üè≠",

      reason: `Strategically positioned: infrastructure ${f.infrastructure.toFixed(0)}/100, land-use ${f.landuse.toFixed(0)}/100, flood safety ${f.flood.toFixed(0)}/100, pollution ${f.pollution.toFixed(0)}/100. Compatible for logistics and industrial use.`,

    });

  }



  // --------------------------------------------------

  // 5Ô∏è‚É£ CONSERVATION / LOW-IMPACT ZONE (NEW, MEANINGFUL)

  // --------------------------------------------------

  if (

    f.vegetation > 70 &&

    f.landuse < 40 &&

    f.population < 40

  ) {

    potentials.push({

      type: "Conservation",

      label: "Ecological Conservation Value",

      class: "pot-green",

      icon: "üå≥",

      reason:

        "High vegetation density and low human footprint indicate strong ecological value. Best suited for conservation, eco-tourism, or carbon-offset initiatives.",

    });

  }



  // --------------------------------------------------

  // 6Ô∏è‚É£ SPECTRAL-AWARE WARNINGS (CONTEXTUAL)

  // --------------------------------------------------

  if (activeSpectral === "hydrology" && f.flood < 50) {

    potentials.push({

      type: "Risk",

      label: "Hydrological Accumulation Zone",

      class: "pot-red",

      icon: "üåä",

      reason:

        "Hydrology overlay indicates water convergence and potential surface runoff accumulation during heavy rainfall events.",

    });

  }



  if (activeSpectral === "thermal" && f.heatIntensity > 65) {

    potentials.push({

      type: "Climate",

      label: "Urban Heat Stress",

      class: "pot-blue",

      icon: "üå°Ô∏è",

      reason:

        "Thermal overlay reveals elevated heat stress. Passive cooling, green roofing, and vegetation buffers are recommended.",

    });

  }



  return potentials;

};



// const PotentialSection = ({ factors, score }) => {

//   const recommendations = getSitePotential(factors);

//   const rating = score > 80 ? "A" : score > 60 ? "B" : score > 40 ? "C" : "F";

  

//   return (

//     <div className="card potential-card glass-morphic" style={{ marginBottom: '16px' }}>

//       <div className="potential-header">

//         <div className="title-stack">

//           <h3>Site Potential Analysis</h3>

//           <p className="subtitle">Algorithmic Terrain Synthesis</p>

//         </div>

//         <div className="rating-badge-container">

//             <span className="rating-label">Grade</span>

//             <span className={`rating-letter grade-${rating}`}>{rating}</span>

//         </div>

//       </div>

//       <div className="recommendations-list">

//         {recommendations.map((rec, idx) => (

//           <div key={idx} className={`potential-item ${rec.class}`}>

//             <div className="potential-tag-row">

//               <span className="potential-icon">{rec.icon}</span>

//               <span className="potential-label">{rec.label}</span>

//             </div>

//             <p className="potential-reason">{rec.reason}</p>

//           </div>

//         ))}

//       </div>

//     </div>

//   );

// };



const PotentialSection = ({ factors, score }) => {

  const recommendations = getSitePotential(factors);

  const rating = score > 80 ? "A" : score > 60 ? "B" : score > 40 ? "C" : "F";

  

  return (

    <div className="card potential-card glass-morphic" style={{ marginBottom: '16px' }}>

      <div className="potential-header enhanced-header">

        <div className="title-stack">

          <h3>Site Potential Analysis</h3>

          <p className="subtitle">Algorithmic Terrain Synthesis</p>

        </div>

        

        {/* Force these to be side-by-side with a new wrapper class */}

        <div className="geo-score-container">

          <div className="index-box">

            {/* <span className="geo-label">INDEX</span> */}

            <span className="geo-value">{score?.toFixed(0)}%</span>

          </div>

          <div className={`grade-box grade-${rating}`}>

            <span className="geo-label forced-white-label">GRADE</span>

            <span className="geo-value">{rating}</span>

          </div>

        </div>

      </div>



      <div className="recommendations-list">

        {recommendations.map((rec, idx) => (

          <div key={idx} className={`potential-item ${rec.class}`}>

            <div className="potential-tag-row">

              <span className="potential-icon">{rec.icon}</span>

              <span className="potential-label">{rec.label}</span>

            </div>

            <p className="potential-reason">{rec.reason}</p>

          </div>

        ))}

      </div>

    </div>

  );

};



  const FactorsSection = memo(({ 

 

  data, latVal, lngVal, locationName, isDarkMode, viewMode, setViewMode, 

  onOpenHistory, mapVariety, isCompareMode, activeSpectral, mapMode, 

  active3DStyle, setLat, setLng, isSelectingB, handleCompareSelect,

  currentZoom, setCurrentZoom, zoom// ‚úÖ CLEAN NAMES

}) => {



  const nLat = parseFloat(latVal);

  const nLng = parseFloat(lngVal);

  const isValidCoords = !isNaN(nLat) && !isNaN(nLng);

const { factors, category_scores, suitability_score } = data;



  // Metadata for categorized headers

  const categoryConfig = {

    physical_terrain: { icon: "‚õ∞Ô∏è", label: "Physical Terrain" },

    hydrology: { icon: "üíß", label: "Hydrology" },

    environmental: { icon: "üåø", label: "Environmental" },

    climatic: { icon: "üå§Ô∏è", label: "Climatic" },

    socio_econ: { icon: "üèóÔ∏è", label: "Socio-Economic" }

  };

  // const FactorCard = (

  //   <div className="card factors-card">

  //     <div className="factors-header">

  //       <h3>Terrain Factors</h3>

  //       <button className="view-toggle" onClick={() => setViewMode(viewMode === "bars" ? "radar" : "bars")}>

  //           {viewMode === "bars" ? "üï∏Ô∏è Radar View" : "üìä Bar View"}

  //       </button>

  //     </div>



  //     {viewMode === "bars" ? (

  //       <div className="bars-container">

  //         {['rainfall', 'flood', 'landslide', 'soil', 'proximity', 'water', 'pollution', 'landuse'].map(f => (

  //           <FactorBar key={f} label={f.charAt(0).toUpperCase() + f.slice(1)} value={data.factors[f] ?? 0} />

  //         ))}

  //       </div>

  //     ) : (

  //       <div className="radar-container" style={{ height: '300px', width: '100%', position: 'relative' }}>

  //           <RadarChart key={`radar-${nLat}-${nLng}`} data={data.factors} isDarkMode={isDarkMode} />

  //       </div>

  //     )}

  //   </div>

  // );



// --- UPDATED CATEGORIZED FACTOR CARD ---

  const FactorCard = (

    <div className="card factors-card glass-morphic">

      <div className="factors-header">

        <div className="title-stack">

          <h3>Terrain Intelligence</h3>

          <p className="subtitle">14-Factor Geospatial Synthesis</p>

        </div>

        <button className="view-toggle" onClick={() => setViewMode(viewMode === "bars" ? "radar" : "bars")}>

            {viewMode === "bars" ? "üï∏Ô∏è Radar View" : "üìä Bar View"}

        </button>

      </div>



      {viewMode === "bars" ? (

        <div className="categories-wrapper">

          {/* Loop through each of the 5 Major Folders */}

          {Object.entries(factors).map(([catKey, catFactors]) => (

            <div key={catKey} className="factor-category-group animate-in">

              

              {/* MAJOR CATEGORY HEADER */}

              <div className="category-sub-header">

                <div className="cat-title">

                  <span className="cat-icon">{categoryConfig[catKey]?.icon || "üìÇ"}</span>

                  <span className="cat-label">{categoryConfig[catKey]?.label || catKey}</span>

                </div>

                <span className="cat-score-badge">

                  {category_scores?.[catKey]?.toFixed(0) || 0}%

                </span>

              </div>

              

              {/* INDIVIDUAL SUB-FACTORS (The 14 Factors) */}

              <div className="bars-container categorized">

                {Object.entries(catFactors).map(([fKey, fData]) => {

                  const rawVal = typeof fData === 'object' ? (fData.scaled_score ?? fData.value) : fData;

                  const displayVal = Math.min(100, Math.max(0, Number(rawVal) || 0));

                  return (

                  <FactorBar 

                    key={fKey} 

                    label={fKey.replace(/_/g, ' ').toUpperCase()} 

                    value={displayVal}

                  />

                );})}

              </div>

            </div>

          ))}

          

         {/* TOTAL SUITABILITY SUMMARY */}

          <div className="suitability-summation-bar">

            <label>Aggregated Index</label>

            <div className="summation-value">

              <strong>{suitability_score?.toFixed(1)}%</strong>

            </div>

          </div>

        </div>

  // Inside FactorsSection memo, update the RadarChart component call:

) : (

  <div className="radar-container" style={{ height: '350px', width: '100%', position: 'relative' }}>

      <RadarChart 

        key={`radar-${nLat}-${nLng}`} 

        data={Object.values(factors).reduce((acc, cat) => ({ ...acc, ...cat }), {})} 

        isDarkMode={isDarkMode}

        categoryScores={category_scores}

      />

  </div>

)}

    </div>

  );

  return (

    <>

      <div className={`card hero-card glass-morphic ${data.suitability_score < 40 ? 'danger-glow' : ''}`}>

 

<div className="mini-map-context">

  {isValidCoords ? (

    mapMode === "2D" ? (

      /* 2D Minimap */

      <MapContainer 

        center={[nLat, nLng]} 

        // zoom={15} 

        zoom={16}               // ‚úÖ REQUIRED: Pass the state

    // key={`map-2d-${zoom}`}

        zoomControl={false} 

        dragging={false} 

        scrollWheelZoom={false}    // üîí LOCK: Prevents zooming inside the mini-card

    doubleClickZoom={false}

    touchZoom={false}

        style={{ height: "100%", width: "100%" }}

        key={`minimap-${nLat}-${nLng}`}

      >

        {/* üöÄ THIS IS THE FIX: It watches lat/lng and moves the engine */}

        <TileLayer url={varieties[mapVariety] || varieties.hybrid} />

        {/* ‚úÖ RESTORED FOR MINIMAP */}

        {activeSpectral !== "standard" && spectralLayers[activeSpectral] && (

          <TileLayer 

            key={activeSpectral} 

            url={spectralLayers[activeSpectral]} 

            opacity={0.7} 

            zIndex={100} 

          />

        )}

  

    {/* Use a simple Marker instead of LocationMarker to keep it static */}

    <Marker position={[nLat, nLng]} />

      </MapContainer>

    ) : (

      /* 3D Minimap */

      <ProMap 

        lat={nLat} 

        lng={nLng} 

        setLat={setLat} // Fixed: Passing setter to 3D

    setLng={setLng}

    // zoom={currentZoom}

    zoom={16}

        factors={data.factors} 

        isDarkMode={isDarkMode} 

        activeStyle={active3DStyle}

        interactive={false}

      />

    )

  ) : (

    <div className="empty-results" style={{ fontSize: '11px' }}>Awaiting Analysis...</div>

  )}

  <div className="mini-map-label">{mapMode} Tactical Preview</div>

</div>







        <div className="card-coordinates">

          <span>LAT: {isValidCoords ? nLat.toFixed(4) : "0.0000"}</span>

          <span>LNG: {isValidCoords ? nLng.toFixed(4) : "0.0000"}</span>

        </div>

        

        <div className="suitability-header-row">

          <h3>Suitability Intelligence</h3>

        </div>



        <div className="score-value" style={{ "--score-color": data.suitability_score < 40 ? "#ef4444" : data.suitability_score < 70 ? "#f59e0b" : "#10b981"}}>

          {data.suitability_score?.toFixed(1)}

        </div>

        <div className={`status-pill ${data.label?.toLowerCase().replace(/\s+/g, '-')}`}>{data.label}</div>

        {(data.water_body_snippet || data.protected_snippet) && (

          <div className="suitability-snippet">

            {data.water_body_snippet && (

              <span className="snippet-water">Located on: <strong>{data.water_body_snippet}</strong></span>

            )}

            {data.protected_snippet && (

              <span className="snippet-protected">Protected / Forest: <strong>{data.protected_snippet}</strong></span>

            )}

          </div>

        )}

          <div className="history-action-container">

          <button 

            className="history-pro-btn" 

            onClick={() => onOpenHistory(data, locationName, latVal, lngVal)} 

            title="Execute Temporal Analysis"

          >

            <span className="pulse-dot"></span>

            <span className="btn-text">ANALYZE HISTORICAL TRENDS</span>

            <span className="btn-icon">‚Üí</span>

          </button>

        </div>

      </div>

      {/* 2. Factor Card: Terrain Factors (Charts/Bars) */}

      {FactorCard}



      

    </>

  );

});



/* --- Sync map center to state on pan (so zoom +/- uses current view) --- */

const MapCenterSync = ({ setViewCenter }) => {

  const map = useMap();

  useMapEvents({

    moveend() {

      const c = map.getCenter();

      if (c && setViewCenter) setViewCenter([c.lat, c.lng]);

    },

  });

  return null;

};



/* --- TACTICAL MAP CONTROLLER --- */

const TacticalMapController = ({ 

  latA, lngA, latB, lngB, currentLat, currentLng, 

  setLat, setLng, isSelectingB, setBLatInput, setBLngInput, 

  isTacticalMode, setViewCenter, setZoom 

}) => {

  const map = useMap();



  useMapEvents({

    click(e) {

      const clickedLat = e.latlng.lat.toString();

      const clickedLng = e.latlng.lng.toString();

      const pt = [e.latlng.lat, e.latlng.lng];

      if (setViewCenter) setViewCenter(pt);

      if (isSelectingB) {

        setBLatInput(clickedLat);

        setBLngInput(clickedLng);

      } else {

        setLat(clickedLat);

        setLng(clickedLng);

      }

    },

  });



  useEffect(() => {

    const duration = 1.2;

    window.snapToA = () => {

      const nLat = parseFloat(latA);

      const nLng = parseFloat(lngA);

      if (Number.isFinite(nLat) && Number.isFinite(nLng)) {

        map.flyTo([nLat, nLng], 16, { animate: true, duration });

        if (setZoom) setZoom(16);

      }

    };

    window.snapToB = () => {

      const nLat = parseFloat(latB);

      const nLng = parseFloat(lngB);

      if (Number.isFinite(nLat) && Number.isFinite(nLng)) {

        map.flyTo([nLat, nLng], 16, { animate: true, duration });

        if (setZoom) setZoom(16);

      }

    };

    window.snapToLive = () => {

      // Check if map exists before proceeding

      if (!map) {

        console.warn('Map not initialized yet');

        return;

      }

      

      // Get actual device location using geolocation API

      if (navigator.geolocation) {

        navigator.geolocation.getCurrentPosition(

          (pos) => {

            const deviceLat = pos.coords.latitude;

            const deviceLng = pos.coords.longitude;

            if (Number.isFinite(deviceLat) && Number.isFinite(deviceLng)) {

              map.flyTo([deviceLat, deviceLng], 16, { animate: true, duration });

              if (setZoom) setZoom(16);

              // Also update the lat/lng state to reflect device location

              setLat(deviceLat.toString());

              setLng(deviceLng.toString());

            }

          },

          (error) => {

            console.error('Error getting device location:', error);

            // Fallback to currentLat/currentLng if geolocation fails

            const nLat = parseFloat(currentLat);

            const nLng = parseFloat(currentLng);

            if (Number.isFinite(nLat) && Number.isFinite(nLng)) {

              map.flyTo([nLat, nLng], 16, { animate: true, duration });

              if (setZoom) setZoom(16);

            }

          }

        );

      } else {

        // Fallback to currentLat/currentLng if geolocation not available

        const nLat = parseFloat(currentLat);

        const nLng = parseFloat(currentLng);

        if (Number.isFinite(nLat) && Number.isFinite(nLng)) {

          map.flyTo([nLat, nLng], 16, { animate: true, duration });

          if (setZoom) setZoom(16);

        }

      }

    };

    return () => {

      delete window.snapToA;

      delete window.snapToB;

      delete window.snapToLive;

    };

  }, [map, latA, lngA, latB, lngB, currentLat, currentLng, setZoom,setLat,setLng]);



  // üé® Icon Factory

  const createIcon = (color) => new L.Icon({

    iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`,

    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',

    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34]

  });



  // Convert inputs to numbers safely for rendering

  const posA = [parseFloat(latA), parseFloat(lngA)];

  const posB = [parseFloat(latB), parseFloat(lngB)];

  const posLive = [parseFloat(currentLat), parseFloat(currentLng)];



  // üöÄ THE FIXED RETURN: Properly contained within the function braces

  return (

    <>

      {/* üîµ SITE A: Visible only if Tactical Mode is ON */}

      {isTacticalMode && Number.isFinite(posA[0]) && (

        <Marker position={posA} icon={createIcon('blue')}>

          <Popup>Site A: Analyzed Target</Popup>

        </Marker>

      )}



      {/* üî¥ SITE B: Visible only if Tactical Mode is ON */}

      {isTacticalMode && Number.isFinite(posB[0]) && (

        <Marker position={posB} icon={createIcon('red')}>

          <Popup>Site B: Comparison Target</Popup>

        </Marker>

      )}



      {/* üü¢ LIVE POINTER: Always visible */}

      {Number.isFinite(posLive[0]) && (

        <Marker position={posLive} icon={createIcon('green')}>

          <Popup>Current Selection (Neutral)</Popup>

        </Marker>

      )}

    </>

  );

};

  

export default function LandSuitabilityChecker() {



const handleZoomIn = () => {

  setZoom(z => Math.min(z + 1, 20));

};



const handleZoomOut = () => {

  setZoom(z => Math.max(z - 1, 0));

};



// 3. FULLSCREEN FIX: Add a null check to avoid the error you saw

const toggleFullScreen = () => {

  const mapElement = mapViewportRef.current;

  if (!mapElement) return;



  if (!document.fullscreenElement) {

    mapElement.requestFullscreen().catch(err => {

      console.error("Fullscreen failed:", err);

    });

  } else {

    document.exitFullscreen();

  }

};

const [isTacticalMode, setIsTacticalMode] = useState(false);

const [mapMode, setMapMode] = useState("2D"); // "2D" or "3D"

const [active3DStyle, setActive3DStyle] = useState("satellite");

  const initialAnalysisRef = useRef(false); // Flag to prevent double execution on mount

  const [mobileCompareSite, setMobileCompareSite] = useState("A");

  const [deviceLocation, setDeviceLocation] = useState({ lat: null, lng: null });

  const [analysisHistory, setAnalysisHistory] = useState(() => 

      JSON.parse(localStorage.getItem("analysis_history")) || []

  );

  const [isAudioEnabled, setIsAudioEnabled] = useState(false);

  

  const [lat, setLat] = useState(() => localStorage.getItem("geo_lat") || "17.385");

  const [lng, setLng] = useState(() => localStorage.getItem("geo_lng") || "78.4867");

  const [zoom, setZoom] = useState(() => Number(localStorage.getItem("geo_zoom")) || 13);

  const [viewCenter, setViewCenter] = useState(() => {

    const slat = localStorage.getItem("geo_lat") || "17.385";

    const slng = localStorage.getItem("geo_lng") || "78.4867";

    return [parseFloat(slat) || 17.385, parseFloat(slng) || 78.4867];

  });

  const [mapVariety, setMapVariety] = useState(() => localStorage.getItem("geo_map_style") || "streets");

  const [activeTab, setActiveTab] = useState("suitability");

  const [isDarkMode, setIsDarkMode] = useState(() => JSON.parse(localStorage.getItem("geo_theme")) ?? true);

  // const [result, setResult] = useState(() => JSON.parse(localStorage.getItem("geo_last_result")) || null);

  // const [result, setResult] = useState(null);

  const [result, setResult] = useState(() => JSON.parse(localStorage.getItem("geo_last_result")) || null);

  const [compareResult, setCompareResult] = useState(() => JSON.parse(localStorage.getItem("geo_last_compare_result")) || null);

const [isCompareMode, setIsCompareMode] = useState(() => JSON.parse(localStorage.getItem("geo_is_compare")) || false);

const [showLocationB, setShowLocationB] = useState(() => JSON.parse(localStorage.getItem("geo_show_b")) || false);

const [locationAName, setLocationAName] = useState(() => localStorage.getItem("geo_name_a") || "Site A");

const [locationBName, setLocationBName] = useState(() => localStorage.getItem("geo_name_b") || "Site B");

  const [sidebarWidth, setSidebarWidth] = useState(() => Number(localStorage.getItem("sidebar_width")) || 320);

  const [bottomHeight, setBottomHeight] = useState(() => Number(localStorage.getItem("bottom_height")) || 380);

  // LandSuitabilityChecker.js - At the top of the component



  const isResizingSide = useRef(false);

  const isResizingBottom = useRef(false);



  // const [isCompareMode, setIsCompareMode] = useState(false);

  // const [compareResult, setCompareResult] = useState(null);

  const [compareName, setCompareName] = useState("");

  const [isSelectingB, setIsSelectingB] = useState(false);

  const [compareLoading, setCompareLoading] = useState(false);

  const [bLatInput, setBLatInput] = useState("");

  const [bLngInput, setBLngInput] = useState("");

  const [loading, setLoading] = useState(false);

  const [debug] = useState(false);

  const [viewMode, setViewMode] = useState("bars"); 

// Add these near your other useState calls

const [analyzedCoords, setAnalyzedCoords] = useState(() => ({

  lat: localStorage.getItem("geo_lat_analyzed") || null,

  lng: localStorage.getItem("geo_lng_analyzed") || null

}));



const [analyzedCoordsB, setAnalyzedCoordsB] = useState(() => ({

  lat: localStorage.getItem("geo_lat_b_analyzed") || null,

  lng: localStorage.getItem("geo_lng_b_analyzed") || null

}));

const [editingIndex, setEditingIndex] = useState(null);

  const [editingName, setEditingName] = useState("");

  const [savedPlaces, setSavedPlaces] = useState(() => JSON.parse(localStorage.getItem("savedPlaces")) || []);

  // const [analyzedCoords, setAnalyzedCoords] = useState({ lat: null, lng: null });

  // const [analyzedCoordsB, setAnalyzedCoordsB] = useState({ lat: null, lng: null });

  // const [locationAName, setLocationAName] = useState("Site A");

  // const [locationBName, setLocationBName] = useState("Site B");

  // const [showLocationB, setShowLocationB] = useState(false);

  const [isBFromSavedPlace] = useState(false);

  

  const [showNearby, setShowNearby] = useState(false);

  const [nearbyData, setNearbyData] = useState(null);

  const [nearbyLoading, setNearbyLoading] = useState(false);

  const [nearbyDataB, setNearbyDataB] = useState(null);

  const [nearbyLoadingB, setNearbyLoadingB] = useState(false);

  const [showNearbyB, setShowNearbyB] = useState(false);



  const [isGptOpen, setIsGptOpen] = useState(false);

  const [isAnalysisFullscreen, setIsAnalysisFullscreen] = useState(false);

  

  // State variables needed for Digital Twin functionality
  const [isDigitalTwinDragging, setIsDigitalTwinDragging] = useState(false);
  const [digitalTwinPosition, setDigitalTwinPosition] = useState({ x: 0, y: 0 });
  const [digitalTwinStart, setDigitalTwinStart] = useState({ x: 0, y: 0 });
  
  // Chat history for GeoGPT (kept for compatibility)
  const [chatHistory] = useState([{ role: 'assistant', content: 'Hello! I\'m GeoGPT Intelligence. What would you like to know about our geospatial analysis?' }]);
  const chatEndRef = useRef(null);

  const scrollToBottom = useCallback(() => {
    chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, []);

  useEffect(() => { scrollToBottom(); }, [chatHistory, scrollToBottom]);

  const handleDigitalTwinMouseDown = useCallback((e) => {
    e.preventDefault();
    setIsDigitalTwinDragging(true);
    setDigitalTwinStart({
      x: e.clientX - digitalTwinPosition.x,
      y: e.clientY - digitalTwinPosition.y
    });
  }, [digitalTwinPosition]);

  const handleDigitalTwinMouseMove = useCallback((e) => {
    if (isDigitalTwinDragging) {
      const newX = e.clientX - digitalTwinStart.x;
      const newY = e.clientY - digitalTwinStart.y;
      setDigitalTwinPosition({
        x: newX,
        y: newY
      });
    }
  }, [isDigitalTwinDragging, digitalTwinStart]);

  const handleDigitalTwinMouseUp = useCallback(() => {
    setIsDigitalTwinDragging(false);
  }, []);

  useEffect(() => {
    if (isDigitalTwinDragging) {
      document.addEventListener('mousemove', handleDigitalTwinMouseMove);
      document.addEventListener('mouseup', handleDigitalTwinMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleDigitalTwinMouseMove);
        document.removeEventListener('mouseup', handleDigitalTwinMouseUp);
      };
    }
  }, [isDigitalTwinDragging, handleDigitalTwinMouseMove, handleDigitalTwinMouseUp]);

  // Snapshot States

const [snapshotData, setSnapshotData] = useState(null);       // Site A

// const [setSnapshotDataB] = useState(null); 

const [snapshotDataB, setSnapshotDataB] = useState(null);   // Site B

const [snapshotLoading, setSnapshotLoading] = useState(false);



// --- UTILITY FUNCTIONS DEFINED FIRST TO AVOID NO-UNDEF ERRORS ---

  

  const fetchSnapshot = useCallback(async (tLat, tLng) => {

    try {

      const res = await fetch(`${API_BASE}/snapshot_identity`, {

        method: "POST",

        headers: { "Content-Type": "application/json" },

        body: JSON.stringify({ latitude: parseFloat(tLat), longitude: parseFloat(tLng) })

      });

      return await res.json();

    } catch (err) { 

      console.error("Snapshot error:", err);

      return null; 

    }

  }, []);



  const performAnalysis = useCallback(async (tLat, tLng) => {

    try {

      const response = await fetch(`${API_BASE}/suitability`, {



        method: "POST",

        headers: { 

          "Content-Type": "application/json",

          "Accept": "application/json"

        },

        body: JSON.stringify({ latitude: parseFloat(tLat), longitude: parseFloat(tLng), debug }),

      });

      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

      return await response.json();

    } catch (error) {

      console.error("Analysis Request Failed:", error);

      throw error; 

    }

  }, [debug]);



const resolveLocationName = useCallback((targetLat, targetLng, defaultFallback) => {

    const curLat = parseFloat(targetLat).toFixed(4);

    const curLng = parseFloat(targetLng).toFixed(4);



    // Condition 1: Check Saved Places

    const matchedPlace = savedPlaces.find(p => 

      p.lat.toFixed(4) === curLat && p.lng.toFixed(4) === curLng

    );

    if (matchedPlace) return matchedPlace.name;



    // Condition 2: Check if it's the User's current physical device location

    if (isNearbyDevice(targetLat, targetLng, deviceLocation)) {

      return "My Location";

    }



    // Condition 3: Prompt for new name because coordinates changed

    const userName = prompt(`New location detected at ${curLat}, ${curLng}. Enter a name:`);

    return userName || defaultFallback;

}, [savedPlaces, deviceLocation]);





const handleCompareSelect = useCallback(async (tLat, tLng, existingName = null) => {

    setIsSelectingB(false);

    setBLatInput(tLat.toString());

    setBLngInput(tLng.toString());

    

    let name = existingName || resolveLocationName(tLat, tLng, "Site B");

    

    setCompareName(name);

    setLocationBName(name);

    setCompareLoading(true);

    setIsCompareMode(true);

    setCompareResult(null); 



    try { 

      // FIXED: Parallel fetch for both suitability and snapshot identity for Site B

      const [suitResult, snapData] = await Promise.all([

          performAnalysis(tLat, tLng),

          fetchSnapshot(tLat, tLng)

      ]);



      setCompareResult(suitResult);

      setSnapshotDataB(snapData); // Now snapData is correctly defined from the fetch

      // setAnalyzedCoordsB({ lat: tLat.toString(), lng: tLng.toString() });

      // üìç PERSISTENCE FIX: Save analyzed coords so the Red marker stays

        const coordsB = { lat: tLat.toString(), lng: tLng.toString() };

        setAnalyzedCoordsB(coordsB);

        localStorage.setItem("geo_lat_b_analyzed", tLat.toString());

        localStorage.setItem("geo_lng_b_analyzed", tLng.toString());

    } catch (err) { 

      console.error(err); 

    } finally { 

      setCompareLoading(false); 

    }

}, [resolveLocationName, performAnalysis, fetchSnapshot]);



useEffect(() => {

  if (navigator.geolocation) {

    navigator.geolocation.getCurrentPosition((pos) => {

      setDeviceLocation({

        lat: pos.coords.latitude.toFixed(4),

        lng: pos.coords.longitude.toFixed(4)

      });

    });

  }

}, []);







const handleSubmit = useCallback(async (e) => {

  // Safe check for automatic calls from useEffect (where 'e' might be undefined)

  if (e && e.preventDefault) e.preventDefault();



  // Check if coordinates have changed since last analysis

  const hasAChanged = analyzedCoords.lat !== lat || analyzedCoords.lng !== lng;



  // 1. Determine Name A: 

  // Use existing state if set, otherwise use resolver (Saved Places > My Loc > Prompt)

  // Logic preserves your requirement to re-prompt if coordinates moved

  let nameA = locationAName;

  if (locationAName === "Site A" || hasAChanged) {

    nameA = resolveLocationName(lat, lng, "Site A");

    setLocationAName(nameA);

  } else {

    setLocationAName(nameA);

  }



  // Reset results and start loading states

  setResult(null);

  setCompareResult(null);

  setSnapshotData(null);

  

  // Ensure snapshotDataB state is cleared correctly

  if (setSnapshotDataB) setSnapshotDataB(null);

  

  setLoading(true);

  setSnapshotLoading(true);



  // Capture current state of comparison for this specific submission

  const activeCompareMode = showLocationB && bLatInput && bLngInput;



  if (activeCompareMode) {

    setIsCompareMode(true);

    setCompareLoading(true);

    

    // Determine Name B for UI consistency

    const nameB = (locationBName && locationBName !== "Site B") 

      ? locationBName 

      : resolveLocationName(bLatInput, bLngInput, "Site B");

      

    setLocationBName(nameB);

    setCompareName(nameB);

  } else {

    setIsCompareMode(false);

  }



  // Build the list of parallel tasks

  const tasks = [

    performAnalysis(lat, lng),

    fetchSnapshot(lat, lng)

  ];



  if (activeCompareMode) {

    tasks.push(performAnalysis(bLatInput, bLngInput));

    tasks.push(fetchSnapshot(bLatInput, bLngInput));

  }



  try {

    const results = await Promise.allSettled(tasks);



    // --- SITE A RESULTS & UNIFIED HISTORY ---

    if (results[0].status === 'fulfilled') {

      const analysisData = results[0].value;

      setResult(analysisData);

      // const coordsA = { lat, lng };

      setAnalyzedCoords({ lat, lng });

      localStorage.setItem("geo_lat_analyzed", lat);

    localStorage.setItem("geo_lng_analyzed", lng);

      // Identify Score B from the task results (index 2) directly to ensure history accuracy

      const scoreBVal = (activeCompareMode && results[2]?.status === 'fulfilled') 

        ? results[2].value.suitability_score 

        : undefined;



      // Final check for nameB to ensure the history entry isn't saved as default "Site B" if a name exists

      const finalNameB = activeCompareMode 

        ? (locationBName !== "Site B" ? locationBName : resolveLocationName(bLatInput, bLngInput, "Site B")) 

        : null;



      // UNIFIED HISTORY ENTRY: Stores both sites in one row if comparing.

      const newHistoryEntry = {

        name: nameA,

        lat,

        lng,

        score: analysisData.suitability_score,

        timestamp: new Date().getTime(),

        // Comparison Data:

        isCompareMode: activeCompareMode,

        nameB: finalNameB,

        bLat: activeCompareMode ? bLatInput : null,

        bLng: activeCompareMode ? bLngInput : null,

        scoreB: scoreBVal 

      };



      setAnalysisHistory(prev => {

        const updated = [newHistoryEntry, ...prev].slice(0, 20);

        localStorage.setItem("analysis_history", JSON.stringify(updated));

        return updated;

      });

    }



    if (results[1].status === 'fulfilled') {

      setSnapshotData(results[1].value);

    }



    // --- SITE B DATA PROCESSING (UI states only) ---

    if (activeCompareMode) {

      if (results[2] && results[2].status === 'fulfilled') {

        const compareData = results[2].value;

        setCompareResult(compareData);

        setAnalyzedCoordsB({ lat: bLatInput.toString(), lng: bLngInput.toString() });

      }



      if (results[3] && results[3].status === 'fulfilled') {

        if (setSnapshotDataB) setSnapshotDataB(results[3].value);

      }

    }



  } catch (err) {

    console.error("Critical Analysis Error:", err);

  } finally {

    setLoading(false);

    setCompareLoading(false);

    setSnapshotLoading(false);

  }

}, [

  lat, 

  lng, 

  locationAName, 

  locationBName, 

  bLatInput, 

  bLngInput, 

  showLocationB, 

  resolveLocationName, 

  performAnalysis, 

  fetchSnapshot, 

  setSnapshotDataB, 

  setAnalysisHistory,

  analyzedCoords.lat, 

  analyzedCoords.lng,

]);





const mapViewportRef = useRef(null); // Reference for Fullscreen targeting



useEffect(() => {

  const params = new URLSearchParams(window.location.search);

  // 1. Skip logic if currently loading a shared link

  if (params.get("bLat")) return;



  const currentLatB = parseFloat(bLatInput).toFixed(4);

  const currentLngB = parseFloat(bLngInput).toFixed(4);



  // 2. Check if the new coordinates match a Saved Place

  const matchedB = savedPlaces.find(p => 

    parseFloat(p.lat).toFixed(4) === currentLatB && 

    parseFloat(p.lng).toFixed(4) === currentLngB

  );



  if (matchedB) {

    // 3. Adopt saved name

    setLocationBName(matchedB.name);

  } else if (analyzedCoordsB.lat && bLatInput !== analyzedCoordsB.lat.toString()) {

    // 4. Reset to "Site B" and clear old comparison data

    setLocationBName("Site B");

    // setCompareResult(null);

  }

}, [bLatInput, bLngInput, analyzedCoordsB.lat, savedPlaces]);



useEffect(() => {

  const params = new URLSearchParams(window.location.search);

  if (params.get("lat")) return; // Don't interfere with share links



  const currentLat = parseFloat(lat).toFixed(4);

  const currentLng = parseFloat(lng).toFixed(4);



  // 1. Check if the new coordinates match a Saved Place

  const matched = savedPlaces.find(p => 

    p.lat.toFixed(4) === currentLat && p.lng.toFixed(4) === currentLng

  );



  if (matched) {

    // Automatically adopt the saved name

    setLocationAName(matched.name);

  } else if (analyzedCoords.lat && lat !== analyzedCoords.lat.toString()) {

    // 2. Only reset to "Site A" if coordinates moved away from last analysis 

    // AND it's not a saved place

    setLocationAName("Site A");

    // setResult(null); 

  }

}, [lat, lng, analyzedCoords, savedPlaces]); // Added savedPlaces to dependencies



useEffect(() => {

  // Check if we already handled the URL analysis to prevent loops

  if (initialAnalysisRef.current) return;

  const params = new URLSearchParams(window.location.search);



  const sharedLat = params.get("lat");

  const sharedLng = params.get("lng");

  const sharedNameA = params.get("nameA");

  const sharedBLat = params.get("bLat");

  const sharedBLng = params.get("bLng");

  const sharedNameB = params.get("nameB");

  const isSharedCompare = params.get("compare") === "1" || params.get("compare") === "true";

  

  let shouldAnalyze = false;



  if (sharedLat && sharedLng) {

    // 1. Set main location state

    setLat(sharedLat);

    setLng(sharedLng);

    // 2. Persist to Local Storage immediately so other 

    // components don't default to 0.0000

    localStorage.setItem("geo_lat", sharedLat);

    localStorage.setItem("geo_lng", sharedLng);

    // if (sharedNameA) {

    //   // Decode name here so handleSubmit sees a set name and skips the prompt

    //   setLocationAName(decodeURIComponent(sharedNameA));

    // }

    if (sharedNameA) {

      const decodedName = decodeURIComponent(sharedNameA);

      setLocationAName(decodedName);

      localStorage.setItem("geo_name_a", decodedName);

    }

    shouldAnalyze = true; 

  }



  if (isSharedCompare && sharedBLat && sharedBLng) {

    // 2. Set comparison inputs

    setBLatInput(sharedBLat);

    setBLngInput(sharedBLng);

    

    // Decode Site B name

    const decodedB = sharedNameB ? decodeURIComponent(sharedNameB) : "Site B";

    setLocationBName(decodedB);

    setCompareName(decodedB);

    

    // 3. Enable comparison UI modes

    setShowLocationB(true);

    setIsCompareMode(true);

    

    // 4. Trigger Site B analysis immediately using the decoded name to bypass prompts

    handleCompareSelect(sharedBLat, sharedBLng, decodedB);

  }



  // 5. Auto-trigger the main analysis for Site A

  if (shouldAnalyze) {



    initialAnalysisRef.current = true;

    const timer = setTimeout(() => {

      handleSubmit(); 

    }, 500);

    return () => clearTimeout(timer);

  }

  

  // handleSubmit is now included to satisfy the ESLint warning

}, [handleCompareSelect, handleSubmit]);



// ‚úÖ FIX: Ensure comparison history is saved after URL-based analysis (DEPLOYED FIX)

useEffect(() => {

  if (!result || !compareResult || !isCompareMode) return;



  setAnalysisHistory(prev => {

    const exists = prev.some(

      h =>

        h.lat === lat &&

        h.lng === lng &&

        h.bLat === bLatInput &&

        h.bLng === bLngInput

    );

    if (exists) return prev;



    const entry = {

      name: locationAName,

      lat,

      lng,

      score: result.suitability_score,

      isCompareMode: true,

      nameB: locationBName,

      bLat: bLatInput,

      bLng: bLngInput,

      scoreB: compareResult.suitability_score,

      timestamp: Date.now()

    };



    const updated = [entry, ...prev].slice(0, 20);

    localStorage.setItem("analysis_history", JSON.stringify(updated));

    return updated;

  });

}, [

  result,

  compareResult,

  isCompareMode,

  lat,

  lng,

  bLatInput,

  bLngInput,

  locationAName,

  locationBName

]);



 





  



  useEffect(() => {

  // --- Standard UI State ---

  localStorage.setItem("geo_lat", lat);

  localStorage.setItem("geo_lng", lng);

  localStorage.setItem("geo_name_a", locationAName); // Persist Name A

  localStorage.setItem("geo_name_b", locationBName); // Persistence

  localStorage.setItem("geo_is_compare", JSON.stringify(isCompareMode));

  localStorage.setItem("geo_show_b", JSON.stringify(showLocationB));

  localStorage.setItem("geo_zoom", zoom);

  localStorage.setItem("geo_theme", JSON.stringify(isDarkMode));

  localStorage.setItem("geo_map_style", mapVariety);

  localStorage.setItem("sidebar_width", sidebarWidth);

  localStorage.setItem("bottom_height", bottomHeight);

  localStorage.setItem("savedPlaces", JSON.stringify(savedPlaces));

  

  // --- Analysis Results Persistence ---

  if (compareResult) localStorage.setItem("geo_last_compare_result", JSON.stringify(compareResult));

  if (result) {

    localStorage.setItem("geo_last_result", JSON.stringify(result));

  } else {

    localStorage.removeItem("geo_last_result");

  }



  // --- Comparison State Persistence ---

  localStorage.setItem("geo_is_compare", JSON.stringify(isCompareMode));

  localStorage.setItem("geo_show_b", JSON.stringify(showLocationB));

  

  if (showLocationB) {

    localStorage.setItem("geo_lat_b", bLatInput);

    localStorage.setItem("geo_lng_b", bLngInput);

    localStorage.setItem("geo_name_b", locationBName); // Persist Name B

    

    if (compareResult) {

      localStorage.setItem("geo_last_compare_result", JSON.stringify(compareResult));

    }

  }



  // --- Theme Application ---

  document.body.setAttribute("data-theme", isDarkMode ? "dark" : "light");



}, [

  lat, lng, locationAName, zoom, isDarkMode, sidebarWidth, bottomHeight, 

  result, savedPlaces, mapVariety, isCompareMode, showLocationB, 

  bLatInput, bLngInput, locationBName, compareResult

]);



 





  const handleMouseMoveForResize = useCallback((e) => {

    if (isResizingSide.current) {

      const newWidth = e.clientX;

      if (newWidth > 260 && newWidth < 600) setSidebarWidth(newWidth);

    }

    if (isResizingBottom.current) {

      const newHeight = e.clientY;

      if (newHeight > 300 && newHeight < 600) setBottomHeight(newHeight);

    }

  }, []);



  const stopResizing = useCallback(() => {

    isResizingSide.current = false;

    isResizingBottom.current = false;

    document.removeEventListener("mousemove", handleMouseMoveForResize);

    document.removeEventListener("mouseup", stopResizing);

    document.body.style.cursor = "default";

  }, [handleMouseMoveForResize]);



  const startResizingSide = useCallback(() => {

    isResizingSide.current = true;

    document.addEventListener("mousemove", handleMouseMoveForResize);

    document.addEventListener("mouseup", stopResizing);

    document.body.style.cursor = "col-resize";

  }, [handleMouseMoveForResize, stopResizing]);



  const startResizingBottom = useCallback(() => {

    isResizingBottom.current = true;

    document.addEventListener("mousemove", handleMouseMoveForResize);

    document.addEventListener("mouseup", stopResizing);

    document.body.style.cursor = "row-resize";

  }, [handleMouseMoveForResize, stopResizing]);



  const handleNearbyPlaces = async () => {

    if (!lat || !lng) return;

    setNearbyLoading(true);

    try {

      const res = await fetch(`${API_BASE}/nearby_places`, {

        method: "POST",

        headers: { "Content-Type": "application/json" },

        body: JSON.stringify({ latitude: parseFloat(lat), longitude: parseFloat(lng) }),

      });

      if (!res.ok) throw new Error(res.status);

      const data = await res.json();

      setNearbyData(data);

      setShowNearby(true);

    } catch (err) { alert("Backend starting up, please retry in 10s"); } finally { setNearbyLoading(false); }

  };



  const handleNearbyPlacesB = async () => {

    const targetLat = analyzedCoordsB.lat || bLatInput;

    const targetLng = analyzedCoordsB.lng || bLngInput;

    if (!targetLat || !targetLng) return;

    setNearbyLoadingB(true);

    try {

      const res = await fetch(`${API_BASE}/nearby_places`, {

        method: "POST",

        headers: { "Content-Type": "application/json" },

        body: JSON.stringify({ latitude: parseFloat(targetLat), longitude: parseFloat(targetLng) }),

      });

      if (!res.ok) throw new Error(res.status);

      const data = await res.json();

      setNearbyDataB(data);

      setShowNearbyB(true);

    } catch (err) { alert("Backend starting up, please retry in 10s"); } finally { setNearbyLoadingB(false); }

  };





const handleOpenHistory = useCallback((targetData, targetName, targetLat, targetLng) => {

    const base = `${window.location.origin}${(window.location.pathname || '/').replace(/\/?$/, '')}`;

    const url = `${base}/history?lat=${encodeURIComponent(targetLat)}&lng=${encodeURIComponent(targetLng)}&name=${encodeURIComponent(targetName || 'Site A')}`;

    window.open(url, '_blank', 'noopener,noreferrer');

}, []);



  const handleMyLocation = () => {

    if (!navigator.geolocation) return;

    navigator.geolocation.getCurrentPosition((pos) => {

      const deviceLat = pos.coords.latitude;

      const deviceLng = pos.coords.longitude;

      setLat(deviceLat.toString());

      setLng(deviceLng.toString());

      

      // Also move the map view to the user's location

      setViewCenter([deviceLat, deviceLng]);

      setZoom(16);

    });

  };



  const handleSavePlace = () => {

    const name = prompt("Enter a name for this location:");

    if (!name) return;

    setSavedPlaces([...savedPlaces, { name, lat: parseFloat(lat), lng: parseFloat(lng) }]);

  };

const [activeSpectral, setActiveSpectral] = useState("standard");

  const handleMyLocationB = () => {

    if (!navigator.geolocation) return;

    navigator.geolocation.getCurrentPosition((pos) => {

      setBLatInput(pos.coords.latitude.toString());

      setBLngInput(pos.coords.longitude.toString());

      handleCompareSelect(pos.coords.latitude, pos.coords.longitude);

    });

  };



  const handleSavePlaceB = () => {

    if (!compareName) return;

    setSavedPlaces([...savedPlaces, { name: compareName, lat: parseFloat(bLatInput), lng: parseFloat(bLngInput) }]);

  };



  const handleSearchResult = (searchLat, searchLng, searchName) => {

    setLat(searchLat.toString());

    setLng(searchLng.toString());

    setZoom(16);

  };



  // const EvidenceSection = ({ data }) => (

  //   <div className="card evidence-card" style={{ height: 'auto' }}>

  //     <h3>Evidence Details</h3>

  //     <div className="evidence-list">

  //       {['rainfall', 'flood', 'landslide', 'soil', 'proximity', 'water', 'pollution', 'landuse'].map(id => {

  //         const val = data.factors[id] ?? 0;

  //         const meta = data.explanation?.factors_meta?.[id];

  //         if (!meta) return null;

  //         return (

  //           <div key={id} className={`evidence-entry tone-${val < 40 ? "red" : val < 70 ? "yellow" : "green"}`}>

  //             <strong>{id.toUpperCase()} ({val.toFixed(1)})</strong>

  //             <p>{meta.reason}</p>

  //           </div>

  //         );

  //       })}

  //     </div>

  //   </div>

  // );

  const EvidenceSection = ({ data }) => {

    const meta = data.explanation?.factors_meta;



    if (!meta) {

      return (

        <div className="card evidence-card">

          <h3 className="evidence-title">EVIDENCE DETAILS</h3>

          <p>No evidence metadata available.</p>

        </div>

      );

    }



    // Factor display names (all 14 factors)

    const factorLabels = {

      // Physical (2)

      slope: "SLOPE",

      elevation: "ELEVATION", 

      // Hydrology (3)

      flood: "FLOOD",

      water: "WATER",

      drainage: "DRAINAGE",

      // Environmental (3)

      vegetation: "VEGETATION",

      pollution: "POLLUTION",

      soil: "SOIL",

      // Climatic (3)

      rainfall: "RAINFALL",

      thermal: "THERMAL COMFORT",

      intensity: "HEAT INTENSITY",

      // Socio-Economic (3)

      landuse: "LANDUSE",

      infrastructure: "PROXIMITY",

      population: "POPULATION"

    };



    // Generate evidence text if not provided

    const generateEvidence = (factorKey, factor) => {

      if (factor.evidence) return factor.evidence;

      

      const val = factor.value;

      const raw = factor.raw;

      const label = factor.label || "";

      

      // Generate detailed evidence based on factor type

      switch(factorKey) {

        case "slope":

          if (val < 3) return `Slope: ${val}% gradient. VERY FLAT terrain. IDEAL for construction with minimal grading required. No slope stability concerns.`;

          if (val < 8) return `Slope: ${val}% gradient. GENTLE slope. Suitable for most construction types with minor earthwork. Good natural drainage.`;

          if (val < 15) return `Slope: ${val}% gradient. MODERATE slope. Requires careful site planning and grading. May need retaining structures.`;

          if (val < 30) return `Slope: ${val}% gradient. STEEP terrain. HIGH construction costs due to extensive earthwork and stabilization requirements.`;

          return `Slope: ${val}% gradient. VERY STEEP terrain. NOT SUITABLE for standard construction. Landslide and erosion risk elevated.`;

        

        case "elevation":

          if (val < 50) return `Elevation: ${val}m above sea level. LOW elevation coastal/floodplain zone. Monitor for sea-level and flood risks.`;

          if (val < 200) return `Elevation: ${val}m above sea level. LOW to MODERATE elevation. Good accessibility with manageable flood exposure.`;

          if (val < 600) return `Elevation: ${val}m above sea level. MODERATE elevation. Optimal range for most construction activities.`;

          if (val < 1500) return `Elevation: ${val}m above sea level. HIGH elevation. Consider temperature extremes and access logistics.`;

          return `Elevation: ${val}m above sea level. VERY HIGH elevation. Challenging conditions - reduced oxygen, extreme weather.`;

        

        case "flood":

          const waterDist = data?.factors?.hydrology?.water?.distance_km;

          if (waterDist !== undefined) {

            if (waterDist < 0.5) return `COMBINED ASSESSMENT: Flood safety score ${val}/100. Located ${waterDist.toFixed(2)}km from water body. HIGH FLOOD RISK during monsoon/heavy rainfall.`;

            if (waterDist < 1.5) return `COMBINED ASSESSMENT: Flood safety score ${val}/100. Located ${waterDist.toFixed(2)}km from water. MODERATE risk - floods only with exceptional rainfall.`;

            if (waterDist < 3.0) return `COMBINED ASSESSMENT: Flood safety score ${val}/100. Located ${waterDist.toFixed(2)}km from water. LOW flood risk. Natural terrain provides protection.`;

            return `COMBINED ASSESSMENT: Flood safety score ${val}/100. Remote location ${waterDist.toFixed(2)}km from water sources. VERY LOW flood risk.`;

          }

          return `Flood safety score: ${val}/100. ${label}. Analysis based on regional hydrology patterns.`;

        

        case "water":

          const dist = factor.distance_km;

          if (dist !== undefined && dist !== null) {

            if (dist < 0.02) return `Location is ON a water body. Score: 0/100. NOT SUITABLE for terrestrial construction.`;

            if (dist < 0.5) return `Located approximately ${dist.toFixed(2)}km from nearest water body. CLOSE proximity - irrigation advantage but flood monitoring needed.`;

            if (dist < 2.0) return `Located approximately ${dist.toFixed(2)}km from nearest water body. MODERATE water access for utility and agriculture needs.`;

            return `Located approximately ${dist.toFixed(2)}km from nearest water body. DISTANT from surface water - may require well/borewell for water supply.`;

          }

          return `Water proximity score: ${val}/100. ${label}`;

        

        case "vegetation":

          const ndvi = raw || (val / 100);

          if (val < 20) return `Vegetation Index: ${val}/100 (NDVI proxy: ${ndvi.toFixed ? ndvi.toFixed(2) : ndvi}). BARE/BUILT-UP land detected. Urban or barren classification.`;

          if (val < 40) return `Vegetation Index: ${val}/100 (NDVI proxy: ${ndvi.toFixed ? ndvi.toFixed(2) : ndvi}). SPARSE vegetation. Suitable for development with minimal clearing.`;

          if (val < 60) return `Vegetation Index: ${val}/100 (NDVI proxy: ${ndvi.toFixed ? ndvi.toFixed(2) : ndvi}). MODERATE vegetation. Agricultural or mixed land cover.`;

          return `Vegetation Index: ${val}/100 (NDVI proxy: ${ndvi.toFixed ? ndvi.toFixed(2) : ndvi}). DENSE vegetation. May indicate forest/protected area - verify zoning.`;

        

        case "pollution":

          const pm25 = raw;

          if (pm25 !== null && pm25 !== undefined) {

            if (pm25 < 10) return `PM2.5: ${pm25} ¬µg/m¬≥. EXCELLENT air quality. Below WHO Annual Guideline (10 ¬µg/m¬≥). OPTIMAL for residential development.`;

            if (pm25 < 25) return `PM2.5: ${pm25} ¬µg/m¬≥. GOOD air quality. Acceptable for residential and commercial development.`;

            if (pm25 < 50) return `PM2.5: ${pm25} ¬µg/m¬≥. MODERATE air quality. Exceeds WHO guidelines. Industrial/traffic sources may be nearby.`;

            return `PM2.5: ${pm25} ¬µg/m¬≥. POOR air quality. Significantly exceeds safety standards. Air filtration recommended for habitation.`;

          }

          return `Air quality score: ${val}/100. Estimated using satellite aerosol data and regional baseline models.`;

        

        case "soil":

          if (val >= 80) return `Soil quality score: ${val}/100. EXCELLENT bearing capacity and drainage. Ideal loam conditions for construction.`;

          if (val >= 60) return `Soil quality score: ${val}/100. GOOD soil conditions. Standard foundation design adequate.`;

          if (val >= 40) return `Soil quality score: ${val}/100. MODERATE soil quality. May require soil testing and foundation enhancement.`;

          return `Soil quality score: ${val}/100. POOR soil conditions. Clayey/waterlogged terrain. Special foundations required.`;

        

        case "rainfall":

          const rainMm = raw;

          if (rainMm !== null && rainMm !== undefined) {

            if (rainMm < 300) return `Rainfall: ${rainMm}mm/year. LOW rainfall - ARID conditions. IDEAL for construction, minimal flood risk. Irrigation required for agriculture.`;

            if (rainMm < 800) return `Rainfall: ${rainMm}mm/year. MODERATE rainfall. Good balance for construction and agriculture with proper drainage.`;

            if (rainMm < 1500) return `Rainfall: ${rainMm}mm/year. HIGH rainfall. Requires robust drainage systems. Moderate flood susceptibility.`;

            return `Rainfall: ${rainMm}mm/year. EXCESSIVE rainfall. High flood and foundation damage risk. Monsoon region challenges.`;

          }

          return `Rainfall suitability score: ${val}/100. ${label}.`;

        

        case "thermal":

          const tempData = raw;

          if (tempData && typeof tempData === 'object' && tempData.temperature_c !== undefined) {

            if (val >= 80) return `Thermal Comfort Index: ${val}/100. Temperature: ${tempData.temperature_c}¬∞C, Humidity: ${tempData.humidity_pct}%. HIGHLY COMFORTABLE climate conditions.`;

            if (val >= 60) return `Thermal Comfort Index: ${val}/100. Temperature: ${tempData.temperature_c}¬∞C, Humidity: ${tempData.humidity_pct}%. COMFORTABLE conditions with minor seasonal extremes.`;

            if (val >= 40) return `Thermal Comfort Index: ${val}/100. Temperature: ${tempData.temperature_c}¬∞C, Humidity: ${tempData.humidity_pct}%. MARGINAL comfort - consider HVAC requirements.`;

            return `Thermal Comfort Index: ${val}/100. Temperature: ${tempData.temperature_c}¬∞C, Humidity: ${tempData.humidity_pct}%. UNCOMFORTABLE - extreme heat/cold stress.`;

          }

          return `Thermal Comfort Index: ${val}/100. ${label}.`;

        

        case "intensity":

          if (val < 25) return `Heat Stress Index: ${val}/100. LOW heat stress. Comfortable thermal conditions year-round.`;

          if (val < 45) return `Heat Stress Index: ${val}/100. MODERATE heat stress. Some cooling measures recommended during peak hours.`;

          if (val < 65) return `Heat Stress Index: ${val}/100. HIGH heat stress. Active cooling and ventilation essential.`;

          return `Heat Stress Index: ${val}/100. EXTREME heat stress. Significant thermal management infrastructure required.`;

        

        case "landuse":

          const classification = factor.classification || "Unknown";

          if (val <= 15) return `Land-use Classification: ${classification}. Score: ${val}/100. PROTECTED/FOREST area. Legally non-buildable. Conservation zone detected.`;

          if (val <= 40) return `Land-use Classification: ${classification}. Score: ${val}/100. RESTRICTED development potential. Environmental sensitivity detected.`;

          if (val <= 70) return `Land-use Classification: ${classification}. Score: ${val}/100. MODERATE development potential. Agricultural or mixed-use zoning.`;

          return `Land-use Classification: ${classification}. Score: ${val}/100. HIGH development potential. Urban/commercial zoning compatible.`;

        

        case "infrastructure":

          if (val < 30) return `Infrastructure Score: ${val}/100. REMOTE location. Significant infrastructure investment needed for development.`;

          if (val < 50) return `Infrastructure Score: ${val}/100. MODERATE access. May require access road development.`;

          if (val < 70) return `Infrastructure Score: ${val}/100. GOOD road access. Optimal balance of connectivity and tranquility.`;

          return `Infrastructure Score: ${val}/100. EXCELLENT accessibility with nearby road network.`;

        

        case "population":

          const density = factor.density || raw;

          if (density !== null && density !== undefined) {

            if (density < 200) return `Population Density: ${density} people/km¬≤. SPARSE population. Rural/remote area. Limited services and labor availability.`;

            if (density < 600) return `Population Density: ${density} people/km¬≤. MODERATE population. Balanced environment with available workforce and services.`;

            if (density < 1200) return `Population Density: ${density} people/km¬≤. WELL POPULATED. Good access to services, labor, and markets.`;

            return `Population Density: ${density} people/km¬≤. HIGHLY DENSE urban area. Congestion considerations but excellent market access.`;

          }

          return `Population Score: ${val}/100. ${label}.`;

        

        case "drainage":

          if (val >= 80) return `Drainage Capacity: ${val}/100. EXCELLENT drainage. Well-drained terrain with high stream density. Low waterlogging risk.`;

          if (val >= 60) return `Drainage Capacity: ${val}/100. GOOD drainage. Adequate surface water flow. Minor ponding during heavy rainfall.`;

          if (val >= 40) return `Drainage Capacity: ${val}/100. MODERATE drainage. May require drainage improvements for construction.`;

          return `Drainage Capacity: ${val}/100. POOR drainage. Flat/low-lying terrain prone to waterlogging.`;

        

        default:

          return `Score: ${val}/100. ${label}`;

      }

    };



    // Flatten all factors from all categories for display

    const allFactors = [];

    Object.entries(meta).forEach(([category, factors]) => {

      Object.entries(factors).forEach(([factorKey, factor]) => {

        allFactors.push({ category, factorKey, factor });

      });

    });



    return (

        <div className="evidence-section-container">

            <h3 className="evidence-title">EVIDENCE DETAILS</h3>



            <div className="evidence-list">

                {allFactors.map(({ category, factorKey, factor }) => {

                    const displayValue = factor.value !== null && factor.value !== undefined 

                        ? (typeof factor.value === 'number' ? factor.value.toFixed(1) : factor.value)

                        : 'N/A';

                    

                    const numericValue = typeof factor.value === 'number' ? factor.value : 50;

                    

                    const colorClass = numericValue < 40 ? "red" : numericValue < 70 ? "yellow" : "green";

                    

                    const evidenceText = generateEvidence(factorKey, factor);



                    return (

                        <div

                            key={`${category}-${factorKey}`}

                            className={`evidence-item evidence-${colorClass}`}

                        >

                            <div className="evidence-header">

                              <strong className={`evidence-factor-name ${colorClass}`}>

                                {factorLabels[factorKey] || factorKey.toUpperCase()}

                                <span className="evidence-score-inline">

                                  ({displayValue})

                                </span>

                              </strong>

                            </div>



                            <div className="evidence-text">

                                {evidenceText}

                            </div>

                            {factor.source && (

                                <div className="evidence-source">

                                    <small>Source: {factor.source}</small>

                                </div>

                            )}

                        </div>

                    );

                })}

            </div>

        </div>

    );

};



const renderTabContent = (data, coords, name, isFullWidth) => {

  // If isFullWidth (Single Analysis), use your 'results-grid' class

  // If not (Compare Mode), use 'column-stack' to fit inside the narrow pane

  const containerClass = isFullWidth ? "results-grid" : "column-stack";

  

  const currentSnapshot = name === locationAName ? snapshotData : snapshotDataB;

  if (activeTab === "suitability") {

    return (

      <div className={containerClass}>

        <div className={isFullWidth ? "col-1" : ""}>

          

          <FactorsSection 

            data={data} 

            latVal={coords.lat} 

            lngVal={coords.lng} 

            locationName={name}

            isDarkMode={isDarkMode} 

            viewMode={viewMode} 

            setViewMode={setViewMode} 

            onOpenHistory={handleOpenHistory} 

            mapVariety={mapVariety}

            isCompareMode={!isFullWidth}

            activeSpectral={activeSpectral}

            mapMode={mapMode}           // PASS STATE HERE

            active3DStyle={active3DStyle}

            currentZoom={zoom}

            setZoom={setZoom}

            handleZoomIn={handleZoomIn}

            handleZoomOut={handleZoomOut}

            /* NEW PROPS BELOW */

            setLat={setLat}

            setLng={setLng}

            // currentZoom={zoom}           // Local state 'zoom' maps to 'currentZoom'

            setCurrentZoom={setZoom}

            onZoomIn={handleZoomIn}      // Local function maps to 'onZoomIn'

            onZoomOut={handleZoomOut}

            isSelectingB={isSelectingB}

            handleCompareSelect={handleCompareSelect}

          />

        </div>

        <div className={isFullWidth ? "col-2" : ""}>

          {/* <PotentialSection factors={data.factors} score={data.suitability_score} /> */}

          <EvidenceSection data={data} />

        </div>

      </div>

    );

  }



  if (activeTab === "environmental") {

    const cnn = data?.cnn_analysis;

    const confidence = cnn?.confidence || 0;



    // NEW: 3-Tier Tactical Color Logic

    const getCnnTheme = (conf) => {

      if (conf >= 70) return { color: "#10b981", label: "VERIFIED", note: "TARGET LOCKED", class: "high-conf", glow: "rgba(16, 185, 129, 0.2)" }; 

      if (conf >= 40) return { color: "#3b82f6", label: "PROBABLE", note: "PATTERN RECOGNIZED", class: "mid-conf", glow: "rgba(59, 130, 246, 0.2)" }; 

      return { color: "#ef4444", label: "UNCERTAIN", note: "SIGNAL INTERFERENCE", class: "low-conf", glow: "rgba(239, 68, 68, 0.2)" }; 

    };



    const cnnTheme = getCnnTheme(confidence);



    return (

      <div className="environmental-container">

        {/* Landscape Full-Width Cards Layout */}

        <div className="environmental-cards-grid">

          {/* CNN Intelligence Card */}

          <div

            className={`card cnn-tactical-card glass-morphic animate-in ${cnnTheme.class}`}

            style={{ "--status-color": cnnTheme.color, "--status-glow": cnnTheme.glow }}

          >

            <div className="cnn-tactical-header">

              <div className="cnn-title-group">

                <span className="live-tag">LIVE TELEMETRY</span>

                <h3>Visual Intelligence Scan</h3>

              </div>



              <div className="tactical-header-right">

                <div className="model-id-badge">

                  <span className="model-label">ENGINE</span>

                  <span className="model-name">CNN-V2 / MOBILE-NET</span>

                </div>



                <div

                  className="status-indicator-pill"

                  style={{ backgroundColor: cnnTheme.color }}

                >

                  {confidence < 40 && <span className="mini-warn">‚ö†Ô∏è</span>}

                  {cnnTheme.label}

                </div>

              </div>

            </div>



            <div className="cnn-tactical-layout">

              <div className="cnn-visual-container">

                <div

                  className="cnn-frame"

                  style={{ borderColor: cnnTheme.color }}

                >

                  <div

                    className="cnn-image-feed"

                    style={{

                      backgroundImage: cnn?.image_sample

                        ? `url(${cnn.image_sample})`

                        : "none",

                      filter:

                        confidence < 40

                          ? "grayscale(0.4) contrast(1.1) brightness(0.9)"

                          : "none",

                    }}

                  >

                    {cnn?.image_sample && (

                      <div className="scan-telemetry-overlay" />

                    )}

                  </div>



                  <div className="corner-bit tl" />

                  <div className="corner-bit tr" />

                  <div className="corner-bit bl" />

                  <div className="corner-bit br" />

                </div>

              </div>



              <div className="cnn-data-grid">

                <div className="cnn-stat-item">

                  <label>TERRAIN CLASSIFICATION:</label>

                  <strong

                    className="cnn-class-text"

                    style={{ color: cnnTheme.color }}

                  >

                    {cnn?.class || "ANALYZING..."}

                  </strong>

                </div>



                <div className="cnn-stat-item">

                  <div className="label-row">

                    <label>SPECTRAL CONFIDENCE:</label>

                    <span

                      className="confidence-value"

                      style={{ color: cnnTheme.color }}

                    >

                      {confidence}%

                    </span>

                  </div>



                  <div className="tactical-progress-bg">

                    <div

                      className="tactical-progress-fill"

                      style={{

                        width: `${confidence}%`,

                        backgroundColor: cnnTheme.color,

                      }}

                    />

                  </div>

                </div>



                <div

                  className="cnn-alert-box"

                  style={{

                    borderLeftColor: cnnTheme.color,

                    background: `${cnnTheme.color}15`,

                  }}

                >

                  <strong style={{ color: cnnTheme.color }}>

                    {cnnTheme.note}

                  </strong>

                  <p>

                    {confidence < 40

                      ? "Terrain complexity exceeding standard spectral resolution."

                      : `Visual markers confirm high correlation with ${cnn?.class} signatures.`}

                  </p>

                </div>

              </div>

            </div>



            <div className="cnn-footer-telemetry">

              <span>

                RES:{" "}

                {cnn?.telemetry?.resolution_m_per_px != null

                  ? `${cnn.telemetry.resolution_m_per_px}m/px`

                  : "10m/px"}

              </span>

              <span>SENSOR: {cnn?.telemetry?.tile_url_source || "SENTINEL-2 L2A"}</span>

              <span>MODEL: {cnn?.telemetry?.model || "CNN-V2 / MOBILE-NET"}</span>

              <span>TS: {new Date().toLocaleTimeString()}</span>

              {cnn?.telemetry?.verified_by && (

                <span>‚úì {cnn.telemetry.verified_by}</span>

              )}

            </div>

          </div>



          {/* Weather Card */}

          <WeatherCard weather={data?.weather} />



          {/* Hazards Card */}

          <HazardsCard data={currentSnapshot?.hazards_analysis} loading={snapshotLoading} />



          {/* Snapshot Geo Card */}

          <SnapshotGeo data={currentSnapshot} loading={snapshotLoading} />

        </div>

      </div>

    );

  }





  if (activeTab === "infrastructure") {

    const intel = data.strategic_intelligence || {};

    // Use flat_factors (all 14) when available; else derive from nested data.factors

    const flatF = data.flat_factors || (() => {

      const f = data.factors || {};

      const get = (cat, key) => {

        const v = f[cat]?.[key];

        return typeof v === 'object' && v !== null ? v.value : v;

      };

      return {

        landuse: get('socio_econ', 'landuse') ?? 50,

        pollution: get('environmental', 'pollution') ?? 50,

        proximity: get('socio_econ', 'infrastructure') ?? 50,

        soil: get('environmental', 'soil') ?? 50,

        water: get('hydrology', 'water') ?? 50,

        vegetation: get('environmental', 'vegetation') ?? 50

      };

    })();

    const landuseVal = typeof flatF.landuse === 'number' ? flatF.landuse : 50;

    const pollutionVal = typeof flatF.pollution === 'number' ? flatF.pollution : 50;

    const proximityVal = typeof flatF.proximity === 'number' ? flatF.proximity : (typeof flatF.infrastructure === 'number' ? flatF.infrastructure : 50);

    const soilVal = typeof flatF.soil === 'number' ? flatF.soil : 50;

    const waterVal = typeof flatF.water === 'number' ? flatF.water : 50;

    // Carbon Intelligence: Potential based on vegetation/landuse

    const carbonIntelligence = (landuseVal * 0.75).toFixed(1);

    const liveFootprint = ((100 - pollutionVal + (100 - proximityVal)) / 15).toFixed(1);

    const esgScore = Math.round((soilVal + pollutionVal + waterVal) / 3);

    const esgColorClass = esgScore > 75 ? "grade-A" : esgScore > 50 ? "grade-B" : esgScore > 35 ? "grade-C" : "grade-F";

  



    return (

      <div className="infrastructure-container">

        <div className="infrastructure-cards-grid">

          {/* Site Potential Analysis Card */}

          <div className="card glass-morphic intel-card potential-card">

            <div className="intel-header">

              <div className="potential-score-badge">

                {/* <span className="score-value">{data.suitability_score?.toFixed(0) || '---'}%</span>

                <span className="score-label">SCORE</span> */}

              </div>

            </div>

            

            <PotentialSection factors={data.factors} score={data.suitability_score} />

            

            <div className="potential-insights">

              <h4>Development Recommendations</h4>

              <div className="insights-grid">

                <div className="insight-item">

                  <span className="insight-icon">üèóÔ∏è</span>

                  <div className="insight-content">

                    <strong>Construction Viability</strong>

                    <span>{data.suitability_score > 70 ? 'Excellent' : data.suitability_score > 50 ? 'Good' : 'Limited'}</span>

                  </div>

                </div>

                <div className="insight-item">

                  <span className="insight-icon">üå±</span>

                  <div className="insight-content">

                    <strong>Agricultural Potential</strong>

                    <span>{data.factors?.environmental?.soil?.value > 60 ? 'High' : 'Moderate'}</span>

                  </div>

                </div>

                <div className="insight-item">

                  <span className="insight-icon">üèòÔ∏è</span>

                  <div className="insight-content">

                    <strong>Residential Suitability</strong>

                    <span>{data.factors?.socio_econ?.infrastructure?.value > 60 ? 'Favorable' : 'Challenging'}</span>

                  </div>

                </div>

              </div>

            </div>

          </div>



          {/* Sustainability Intelligence Card */}

          <div className="card glass-morphic intel-card sustainability-card">

            <div className="intel-header">

              <h3>üå≥ Sustainability Intelligence</h3>

              <div className={`esg-score-circle ${esgColorClass}`}>

                <span className="esg-val">{esgScore}</span>

                <span className="esg-lab">ESG</span>

              </div>

            </div>

            <div className="carbon-analysis-zone">

              <div className="analysis-row">

                <div className="analysis-item">

                  <label>Carbon Asset</label>

                  <span className="val-green">+{carbonIntelligence} <small>tCO2e/yr</small></span>

                  <div className="mini-progress-bg">

                    <div className="mini-progress-fill green" style={{ width: `${Math.min(carbonIntelligence * 2, 100)}%` }}></div>

                  </div>

                </div>

                <div className="analysis-item">

                  <label>Live Footprint</label>

                  <span className="val-red">-{liveFootprint} <small>tCO2e/yr</small></span>

                  <div className="mini-progress-bg">

                    <div className="mini-progress-fill red" style={{ width: `${Math.min(liveFootprint * 10, 100)}%` }}></div>

                  </div>

                </div>

              </div>

              <div className="net-impact-summary">

                <div className="impact-label">Net Ecosystem Impact</div>

                <div className="impact-value">

                  { (carbonIntelligence - liveFootprint) > 0 ? "CARBON NEGATIVE" : "CARBON POSITIVE" }

                </div>

              </div>

            </div>

            <div className="eligibility-drawer">

              <div className="drawer-item">

                <span>üåø Conservation Credit Match:</span>

                <strong className={esgScore > 65 ? "status-ok" : "status-no"}>

                  {esgScore > 65 ? "HIGHLY ELIGIBLE" : "INELIGIBLE"}

                </strong>

              </div>

              <div className="drawer-item">

                <span>üõ°Ô∏è Biodiversity Buffer:</span>

                <strong>{landuseVal > 60 ? "PREMIUM" : "STANDARD"}</strong>

              </div>

            </div>

            <p className="legal-disclaimer">Estimates based on biomass density and emission intensity.</p>

          </div>



          {/* Dynamic Improvement Roadmap Card */}

          <div className="card glass-morphic intel-card roadmap-card">

            <div className="intel-header">

              <h3>üöß Dynamic Improvement Roadmap</h3>

              {intel.development_readiness && (

                <div className="readiness-badge">

                  <span className={`status-${intel.development_readiness.status}`}>

                    {intel.development_readiness.status.toUpperCase()}

                  </span>

                </div>

              )}

            </div>

            

            {intel.development_readiness && (

              <div className="readiness-summary">

                <div className="readiness-metrics">

                  <div className="metric">

                    <span className="label">Total Investment:</span>

                    <span className="value">{intel.development_readiness.estimated_total_investment || 'Calculating...'}</span>

                  </div>

                  <div className="metric">

                    <span className="label">Time to Ready:</span>

                    <span className="value">{intel.development_readiness.time_to_readiness || 'Calculating...'}</span>

                  </div>

                </div>

              </div>

            )}

            

            <div className="roadmap-list">

              {intel.roadmap?.length > 0 ? intel.roadmap.map((item, i) => (

                <div key={i} className={`roadmap-item priority-${item.priority || 'medium'}`}>

                  <div className="roadmap-task-info">

                    <div className="task-header">

                      <span className="task-name">{item.task}</span>

                      <span className="impact-tag">{item.impact}</span>

                    </div>

                    <p className="tiny-note">{item.note}</p>

                    {item.estimated_cost && (

                      <div className="task-details">

                        <span className="cost">üí∞ {item.estimated_cost}</span>

                        <span className="timeline">‚è±Ô∏è {item.timeline}</span>

                      </div>

                    )}

                  </div>

                </div>

              )) : <div className="nearby-empty">Analyzing location for improvement opportunities...</div>}

            </div>

          </div>



          {/* AI-Driven Strategic Interventions Card */}

          <div className="card glass-morphic intel-card prevention-card">

            <div className="intel-header">

              <h3>üí° AI-Driven Strategic Interventions</h3>

              <p className="subtitle">Location-specific actionable intelligence</p>

            </div>

            

            <div className="interventions-list">

              {intel.interventions?.length > 0 ? intel.interventions.map((intervention, i) => (

                <div key={i} className={`intervention-item urgency-${intervention.urgency || 'medium'}`}>

                  <div className="intervention-header">

                    <span className="intervention-action">{intervention.action || intervention}</span>

                    {intervention.urgency && (

                      <span className={`urgency-badge urgency-${intervention.urgency}`}>

                        {intervention.urgency}

                      </span>

                    )}

                  </div>

                  {intervention.rationale && (

                    <p className="intervention-rationale">{intervention.rationale}</p>

                  )}

                  {intervention.expected_impact && (

                    <div className="intervention-impact">

                      <span className="impact-label">Expected Impact:</span>

                      <span className="impact-value">{intervention.expected_impact}</span>

                    </div>

                  )}

                </div>

              )) : <div className="nearby-empty">Generating AI-powered interventions...</div>}

            </div>

          </div>



          {/* Advanced AI Projection Card */}

          <div className="card glass-morphic intel-card prediction-card">

            <div className="intel-header">

              <h3>üöÄ Advanced AI Projection (2036)</h3>

              <div className="future-score-wrap">

                <span className="current-mini">{data.suitability_score?.toFixed(1)}</span>

                <span className="drift-arrow">‚Üí</span>

                <span className="future-score">{intel.expected_score || 'Calculating...'}%</span>

                {intel.projection_analysis && (

                  <span className={`trend-${intel.projection_analysis.trend_direction}`}>

                    {intel.projection_analysis.trend_direction}

                  </span>

                )}

              </div>

            </div>

            

            {intel.projection_analysis && (

              <div className="projection-insights">

                <div className="confidence-meter">

                  <span className="label">AI Confidence:</span>

                  <div className="confidence-bar">

                    <div 

                      className={`confidence-fill confidence-${intel.projection_analysis.confidence_level}`}

                      style={{ width: intel.projection_analysis.confidence_level === 'high' ? '85%' : '60%' }}

                    ></div>

                  </div>

                  <span className="confidence-value">{intel.projection_analysis.confidence_level}</span>

                </div>

                

                {intel.projection_analysis.key_drivers?.length > 0 && (

                  <div className="key-drivers">

                    <span className="label">Key Change Drivers:</span>

                    <div className="drivers-list">

                      {intel.projection_analysis.key_drivers.map((driver, i) => (

                        <span key={i} className="driver-tag">{driver}</span>

                      ))}

                    </div>

                  </div>

                )}

                

                {intel.projection_analysis.mitigation_potential && (

                  <div className="mitigation-potential">

                    <span className="label">Mitigation Potential:</span>

                    <span className="potential-value">+{intel.projection_analysis.mitigation_potential}%</span>

                  </div>

                )}

              </div>

            )}

            

            <div className="drift-metrics">

              <div className="drift-row">

                <span>Urbanization Risk:</span> 

                <span className="val-red">{intel.metrics?.urban_sprawl || 'Calculating...'}</span>

              </div>

              <div className="drift-row">

                <span>Vegetation Loss:</span> 

                <span className="val-red">{intel.metrics?.veg_loss || 'Calculating...'}</span>

              </div>

              {intel.metrics?.water_security_risk && (

                <div className="drift-row">

                  <span>Water Security Risk:</span> 

                  <span className="val-orange">{intel.metrics.water_security_risk}</span>

                </div>

              )}

              {intel.metrics?.climate_resilience && (

                <div className="drift-row">

                  <span>Climate Resilience:</span> 

                  <span className="val-orange">{intel.metrics.climate_resilience}</span>

                </div>

              )}

              {intel.metrics?.overall_risk_index && (

                <div className="drift-row overall-risk">

                  <span>Overall Risk Index:</span> 

                  <span className={`val-${intel.metrics.overall_risk_index > 20 ? 'red' : intel.metrics.overall_risk_index > 10 ? 'orange' : 'green'}`}>

                    {intel.metrics.overall_risk_index}%

                  </span>

                </div>

              )}

            </div>

          </div>



          {/* Terrain & Slope Analysis Card - Compact Professional Design */}

          <div className="card glass-morphic intel-card terrain-card">

            <div className="intel-header">

              <div className="intel-title-section">

                <h3>‚õ∞Ô∏è Terrain & Slope Analysis</h3>

                <p className="subtitle">Professional Assessment</p>

              </div>

              {/* <div className="terrain-score-badge">

                <span className="score-value">{data.factors?.physical?.slope?.value?.toFixed(1) || '---'}¬∞</span>

                <span className="score-label">SLOPE</span>

              </div> */}

            </div>

            

            <div className="terrain-compact-grid">

              <div className="terrain-metric-row">

                <div className="terrain-metric-item">

                  <div className="metric-icon">üìê</div>

                  <div className="metric-info">

                    <strong>Slope</strong>

                    <span>{data.factors?.physical?.slope?.value?.toFixed(1) || '---'}¬∞</span>

                  </div>

                  <div className="metric-status">

                    <span className={`status-badge ${(data.factors?.physical?.slope?.value || 0) < 8 ? 'good' : (data.factors?.physical?.slope?.value || 0) < 15 ? 'moderate' : (data.factors?.physical?.slope?.value || 0) < 30 ? 'poor' : 'critical'}`}>

                      {(data.factors?.physical?.slope?.value || 0) < 8 ? 'FLAT' : 

                       (data.factors?.physical?.slope?.value || 0) < 15 ? 'MODERATE' : 

                       (data.factors?.physical?.slope?.value || 0) < 30 ? 'STEEP' : 'VERY STEEP'}

                    </span>

                  </div>

                </div>

                

                <div className="terrain-metric-item">

                  <div className="metric-icon">üèîÔ∏è</div>

                  <div className="metric-info">

                    <strong>Elevation</strong>

                    <span>{data.factors?.physical?.elevation?.value?.toFixed(0) || '---'}m</span>

                  </div>

                  <div className="metric-status">

                    <span className={`status-badge ${(data.factors?.physical?.elevation?.value || 0) < 100 ? 'low' : (data.factors?.physical?.elevation?.value || 0) < 500 ? 'medium' : (data.factors?.physical?.elevation?.value || 0) < 1500 ? 'high' : 'extreme'}`}>

                      {(data.factors?.physical?.elevation?.value || 0) < 100 ? 'LOWLAND' : 

                       (data.factors?.physical?.elevation?.value || 0) < 500 ? 'PLAINS' : 

                       (data.factors?.physical?.elevation?.value || 0) < 1500 ? 'HILLS' : 'MOUNTAINS'}

                    </span>

                  </div>

                </div>

                

                <div className="terrain-metric-item">

                  <div className="metric-icon">üöß</div>

                  <div className="metric-info">

                    <strong>Viability</strong>

                    <span>

                      {(data.factors?.physical?.slope?.value || 0) < 8 ? 'Excellent' : 

                       (data.factors?.physical?.slope?.value || 0) < 15 ? 'Good' : 

                       (data.factors?.physical?.slope?.value || 0) < 30 ? 'Challenging' : 'Limited'}

                    </span>

                  </div>

                  <div className="metric-status">

                    <span className={`status-badge ${(data.factors?.physical?.slope?.value || 0) < 8 ? 'excellent' : (data.factors?.physical?.slope?.value || 0) < 15 ? 'good' : (data.factors?.physical?.slope?.value || 0) < 30 ? 'challenging' : 'not-recommended'}`}>

                      {(data.factors?.physical?.slope?.value || 0) < 8 ? 'IDEAL' : 

                       (data.factors?.physical?.slope?.value || 0) < 15 ? 'SUITABLE' : 

                       (data.factors?.physical?.slope?.value || 0) < 30 ? 'DIFFICULT' : 'NOT RECOMMENDED'}

                    </span>

                  </div>

                </div>

              </div>

            </div>



            <div className="terrain-quick-insights">

              <div className="insight-row">

                <div className="insight-item">

                  <span className="insight-icon">‚ö°</span>

                  <div className="insight-content">

                    <strong>Earthwork</strong>

                    <span>

                      {(data.factors?.physical?.slope?.value || 0) < 5 ? 'Minimal' :

                       (data.factors?.physical?.slope?.value || 0) < 10 ? 'Low' :

                       (data.factors?.physical?.slope?.value || 0) < 20 ? 'Moderate' : 'High'}

                    </span>

                  </div>

                </div>

                <div className="insight-item">

                  <span className="insight-icon">üõ°Ô∏è</span>

                  <div className="insight-content">

                    <strong>Walls</strong>

                    <span>

                      {(data.factors?.physical?.slope?.value || 0) < 8 ? 'Not Required' :

                       (data.factors?.physical?.slope?.value || 0) < 15 ? 'Partial' :

                       (data.factors?.physical?.slope?.value || 0) < 25 ? 'Extensive' : 'Major'}

                    </span>

                  </div>

                </div>

                <div className="insight-item">

                  <span className="insight-icon">üí∞</span>

                  <div className="insight-content">

                    <strong>Cost Impact</strong>

                    <span>

                      {(data.factors?.physical?.slope?.value || 0) < 8 ? 'Standard' :

                       (data.factors?.physical?.slope?.value || 0) < 15 ? 'Moderate' :

                       (data.factors?.physical?.slope?.value || 0) < 30 ? 'High' : 'Very High'}

                    </span>

                  </div>

                </div>

                <div className="insight-item">

                  <span className="insight-icon">‚è±Ô∏è</span>

                  <div className="insight-content">

                    <strong>Build Time</strong>

                    <span>

                      {(data.factors?.physical?.slope?.value || 0) < 8 ? 'Normal' :

                       (data.factors?.physical?.slope?.value || 0) < 15 ? '+2-4 weeks' :

                       (data.factors?.physical?.slope?.value || 0) < 30 ? '+1-3 months' : '+3+ months'}

                    </span>

                  </div>

                </div>

              </div>

            </div>



            <div className="terrain-recommendation">

              <div className="recommendation-header">

                <span className="rec-icon">

                  {(data.factors?.physical?.slope?.value || 0) < 8 ? '‚úÖ' :

                   (data.factors?.physical?.slope?.value || 0) < 15 ? 'üëç' :

                   (data.factors?.physical?.slope?.value || 0) < 30 ? '‚ö†Ô∏è' : 'üö´'}

                </span>

                <span className="rec-title">

                  {(data.factors?.physical?.slope?.value || 0) < 8 ? 'Excellent for all development types' :

                   (data.factors?.physical?.slope?.value || 0) < 15 ? 'Suitable with minor planning' :

                   (data.factors?.physical?.slope?.value || 0) < 30 ? 'Requires extensive engineering' :

                   'Not recommended for standard construction'}

                </span>

              </div>

            </div>

          </div>



          {/* Digital Twin Infrastructure Simulation Card - Moved to Analysis */}

          <div 

            className={`card glass-morphic intel-card digital-twin-card draggable-digital-twin ${isDigitalTwinDragging ? 'dragging' : ''}`}

            style={{

              position: 'relative',

              transform: `translate(${digitalTwinPosition.x}px, ${digitalTwinPosition.y}px)`

            }}

          >

            <div className="intel-header">

              <h3>üèóÔ∏è Digital Twin Infrastructure Simulation</h3>

              <p className="subtitle">Interactive Development Impact Analysis & Planning</p>

              <div className="drag-handle" onMouseDown={handleDigitalTwinMouseDown}>‚ãÆ‚ãÆ</div>

            </div>

            <div className="impact-info">

              <p className="impact-description">

                üí° <strong>Impact Simulation:</strong> This advanced digital twin allows you to simulate various development scenarios and their environmental impacts in real-time. 

                Try placing buildings, roads, or infrastructure to see immediate effects on the ecosystem.

              </p>

            </div>

            <DigitalTwin 

              location={{ lat: lat, lng: lng, factors: data.factors }}

              onImpactUpdate={(impactData) => {

                console.log('Development impact:', impactData);

              }}

            />

          </div>

        </div>

      </div>

    );

  }



  // // Fallback return to avoid "undefined" errors

  // return null;

};

  return (

    <div className="app-shell">



      <AudioLandscape 

  // Select factors based on which site is active in compare mode

  activeFactors={isCompareMode 

    ? (mobileCompareSite === "A" ? result?.factors : compareResult?.factors) 

    : result?.factors

  } 

  // NEW: Pass the label (e.g. "Not Suitable (Waterbody)")

  resultLabel={isCompareMode

    ? (mobileCompareSite === "A" ? result?.label : compareResult?.label)

    : result?.label

  }

  isEnabled={isAudioEnabled}

  isLoading={loading || compareLoading}

/>

      <TopNav isDarkMode={isDarkMode} setIsDarkMode={setIsDarkMode} isAudioEnabled={isAudioEnabled} setIsAudioEnabled={setIsAudioEnabled} analysisHistory={analysisHistory} onSearchResult={handleSearchResult} />

      

      <SideBar

        onSearchResult={handleSearchResult}

        lat={lat} setLat={setLat} lng={lng} setLng={setLng}

        locationAName={locationAName} setLocationAName={setLocationAName}

        loading={loading} handleSubmit={handleSubmit}

        handleMyLocation={handleMyLocation} handleSavePlace={handleSavePlace}

        handleNearbyPlaces={handleNearbyPlaces}

        nearbyLoading={nearbyLoading}

        nearbyData={nearbyData}

        result={result} showLocationB={showLocationB}

        setShowLocationB={setShowLocationB} locationBName={locationBName}

        isSelectingB={isSelectingB} setIsSelectingB={setIsSelectingB}

        bLatInput={bLatInput} setBLatInput={setBLatInput}

        bLngInput={bLngInput} setBLngInput={setBLngInput}

        savedPlaces={savedPlaces} handleCompareSelect={handleCompareSelect}

        compareLoading={compareLoading} isCompareMode={isCompareMode}

        setCompareResult={setCompareResult}       // <--- Add this

        setSnapshotDataB={setSnapshotDataB}       // <--- Add this

        setLocationBName={setLocationBName}

        setIsCompareMode={setIsCompareMode}

        handleMyLocationB={handleMyLocationB}

        handleSavePlaceB={handleSavePlaceB}

        isBFromSavedPlace={isBFromSavedPlace}

        setSavedPlaces={setSavedPlaces}

        sidebarWidth={sidebarWidth} startResizingSide={startResizingSide}

        analyzedCoordsB={analyzedCoordsB}

        nearbyLoadingB={nearbyLoadingB}

        handleNearbyPlacesB={handleNearbyPlacesB}

        showNearby={showNearby}

        setShowNearby={setShowNearby}

        compareResult={compareResult}

        editingIndex={editingIndex}

        setEditingIndex={setEditingIndex}

        editingName={editingName}

        setEditingName={setEditingName}

        setAnalyzedCoordsB={setAnalyzedCoordsB}

      />



      <main className="main-content" style={{ display: 'flex', flexDirection: 'column', flex: 1, overflow: 'hidden' }}>

        <section className="map-container" style={{ flex: 1, position: 'relative' }}>

        {/* üéØ MOVE THE REF TO WRAP EVERYTHING */}

  <div

    ref={mapViewportRef}

    className="map-viewport"

    style={{ height: "100%", width: "100%", position: "relative", background: "#000" }}

  >

        {/* TACTICAL ZOOM CONTROLS (Left side of map) */}

          <div className="tactical-zoom-hud">

            <button onClick= {handleZoomIn}>+</button>

            <div className="zoom-divider" />

            <button onClick= {handleZoomOut}>‚àí</button>

          </div>

        {/* TACTICAL ENGINE TOGGLE */}

 

        <div className="engine-switch-container">

  <button 

    className={`switch-btn ${mapMode === "2D" ? "active" : ""}`}

    onClick={() => setMapMode("2D")}

    title="Standard 2D"

  >

    2D

  </button>

  <button 

    className={`switch-btn ${mapMode === "3D" ? "active" : ""}`}

    onClick={() => setMapMode("3D")}

    title="Tactical 3D"

  >

    3D

  </button>

  <div className="vertical-divider" />

            <button className="fullscreen-btn" onClick={toggleFullScreen} title="Map Focus Mode">‚õ∂</button>

</div>

    

    <div className="map-variety-picker">

      <label className="picker-header">üó∫Ô∏è Map Variety</label>

      {mapMode === "2D" ? (

        <>

          <select value={mapVariety} onChange={(e) => setMapVariety(e.target.value)} className="variety-select">

            <optgroup label="Google Maps">

          <option value="hybrid">Satellite Hybrid</option>

          <option value="satellite">Pure Satellite</option>

          <option value="terrain">Physical Terrain</option>

        </optgroup>

        <optgroup label="Analysis Themes">

          <option value="dark">Dark Matter (Pro)</option>

          <option value="topo">Topographic (Technical)</option>

          <option value="streets">Standard Streets</option>

          <option value="light">Minimalist Light</option>

        </optgroup>

          </select>



          <div className="spectral-toggle-bar">

            <button className={activeSpectral === "ndvi" ? "active" : ""} onClick={() => setActiveSpectral(activeSpectral === "ndvi" ? "standard" : "ndvi")}>üåø NDVI</button>

            <button className={activeSpectral === "thermal" ? "active" : ""} onClick={() => setActiveSpectral("thermal")}>üî• Heat</button>

            <button className={activeSpectral === "hydrology" ? "active" : ""} onClick={() => setActiveSpectral("hydrology")}>üíß Flow</button>

          </div>

        </>

      ) : (

        <select value={active3DStyle} onChange={(e) => setActive3DStyle(e.target.value)} className="variety-select">

          <option value="satellite">üõ∞Ô∏è 3D Satellite</option>

          <option value="topo">üèîÔ∏è 3D Topographic</option>

          <option value="dark">üï∂Ô∏è 3D Stealth</option>

          <option value="nature">üå± 3D Nature</option>

          <option value="streets">üèôÔ∏è 3D Urban (Buildings)</option> {/* New */}

    <option value="outdoor">‚õÖ 3D Atmospheric</option>

        </select>

      )}

    </div>





   <div className="tactical-mode-toggle-container">

     

  {/* Wrap the top part in a row-content div */}

  <div className="toggle-row-content">

    <span className="toggle-label">Geo-Triad</span>

    <label className="switch-attractive">

      <input 

        type="checkbox" 

        checked={isTacticalMode} 

        onChange={() => setIsTacticalMode(!isTacticalMode)} 

      />

      <span className="slider-attractive"></span>

    </label>

  </div>

   {isTacticalMode && (

    <div className="tactical-snap-controls animate-slide-in">

       <button className="snap-btn btn-a" onClick={() => window.snapToA?.()}>A</button>

       <button className="snap-btn btn-b" onClick={() => window.snapToB?.()}>B</button>

       <button className="snap-btn btn-live" onClick={() => window.snapToLive?.()}>üìç</button>

    </div>

  )}

</div>





    {mapMode === "2D" ? (

    

<MapContainer

key={`map-${lat}-${lng}-${zoom}`}

center={viewCenter}

  zoom={zoom}

  zoomControl={false}

  style={{ height: "100%", width: "100%" }}

>

  <MapCenterSync setViewCenter={setViewCenter} />

  <TileLayer url={varieties[mapVariety]} />



  {activeSpectral !== "standard" && spectralLayers[activeSpectral] && (

    <TileLayer url={spectralLayers[activeSpectral]} opacity={0.6} />

  )}



<TacticalMapController 

    latA={analyzedCoords.lat}

    lngA={analyzedCoords.lng}

    latB={analyzedCoordsB.lat}

    lngB={analyzedCoordsB.lng}

    currentLat={lat}

    currentLng={lng}

    setLat={setLat}

    setLng={setLng}

  isSelectingB={isSelectingB}

  setBLatInput={setBLatInput}

  setBLngInput={setBLngInput}

  isTacticalMode={isTacticalMode}

  setViewCenter={setViewCenter}

  setZoom={setZoom}

  />



</MapContainer>



    ) : (

      <ProMap 

        lat={lat} 

        lng={lng} 

         zoom={zoom} 

         setLat={setLat}      // ‚úÖ REQUIRED

  setLng={setLng} 

        factors={result?.factors} 

        isDarkMode={isDarkMode} 

        activeStyle={active3DStyle} 

        interactive={true}

        // üöÄ ADD THESE PROPS TO SYNC WITH 3D

    isTacticalMode={isTacticalMode}

    latA={analyzedCoords.lat}

    lngA={analyzedCoords.lng}

    latB={analyzedCoordsB.lat}

    lngB={analyzedCoordsB.lng}

      />

    )}

    </div>

  </section>

        <div className="horizontal-resizer" onMouseDown={startResizingBottom} />



            <section className="results-container" style={{ height: `${bottomHeight}px`, flex: `0 0 ${bottomHeight}px`, overflowY: 'auto' }}>

            

            {/* The result check wraps everything below */}

            {/* {result ? ( */}

            {result || loading || compareLoading ? (

              <>

                {/* 1. Tab Bar Navigation (Visible only when result exists) - Moved outside viewport */}

                <div className={`results-tab-bar glass-morphic ${isAnalysisFullscreen ? 'fullscreen' : ''}`}>

                  <div className="tab-buttons-container">

                    <button className={activeTab === "suitability" ? "active" : ""} onClick={() => setActiveTab("suitability")}>üéØ Suitability</button>

                    <button className={activeTab === "environmental" ? "active" : ""} onClick={() => setActiveTab("environmental")}>üåê Locational Intelligence</button>

                    <button className={activeTab === "infrastructure" ? "active" : ""} onClick={() => setActiveTab("infrastructure")}>üèóÔ∏è Strategic Utility</button>

                  </div>

                  <div className="fullscreen-controls">

                    {isAnalysisFullscreen ? (

                      <button 

                        className="close-fullscreen-btn" 

                        onClick={() => setIsAnalysisFullscreen(false)}

                        title="Exit Fullscreen (ESC)"

                      >

                        ‚úï

                      </button>

                    ) : (

                      <button 

                        className="fullscreen-tab-btn" 

                        onClick={() => setIsAnalysisFullscreen(true)}

                        title="Fullscreen Analysis (F11)"

                      >

                        ‚õ∂

                      </button>

                    )}

                  </div>

                </div>



               {/* 2. Loading Overlay: This will now appear OVER the placeholder space immediately */}

                {(loading || compareLoading) && (

                  <div className="loading-overlay">

                    <div className="spinner"></div>

                    <p>Analyzing Terrain Data...</p>

                  </div>

                )}

                {/* 3. Data Viewport */}

                <div className={`tab-viewport ${isAnalysisFullscreen ? 'fullscreen' : ''}`}>

                  {/* Floating Close Button for Fullscreen */}

                  {isAnalysisFullscreen && (

                    <button 

                      className="floating-close-btn" 

                      onClick={() => setIsAnalysisFullscreen(false)}

                      title="Exit Fullscreen (ESC)"

                    >

                      ‚úï

                    </button>

                  )}

                  

                  {/* SINGLE ANALYSIS VIEW */}

                  {!isCompareMode && result &&(

                    <div className="single-analysis-view">

                      <h4 className="pane-header">{locationAName.toUpperCase()} - FULL TERRAIN REPORT</h4>

                      {renderTabContent(result, analyzedCoords, locationAName, true)}

                    </div>

                  )}



                

                  {isCompareMode && (

                    <div className="mobile-location-tabs glass-morphic only-mobile">

                      <button 

                        className={mobileCompareSite === "A" ? "active" : ""} 

                        onClick={() => setMobileCompareSite("A")}

                      >

                        üìç {locationAName}

                      </button>

                      <button 

                        className={mobileCompareSite === "B" ? "active" : ""} 

                        onClick={() => setMobileCompareSite("B")}

                      >

                        üìç {locationBName || "Site B"}

                      </button>

                    </div>

                  )}

                  {isCompareMode && (

                    <div className="compare-layout-ditto">

                      {/* Site A Pane */}

                      <div className={`compare-pane-ditto ${mobileCompareSite === "A" ? "show-mobile" : "hide-mobile"}`}>

                        <h4 className="pane-header only-desktop">{locationAName.toUpperCase()}</h4>

                        {result ? renderTabContent(result, analyzedCoords, locationAName, false) : <div className="empty-results">Analyzing Site A...</div>}

                      </div>



                      {/* Site B Pane */}

                      <div className={`compare-pane-ditto ${mobileCompareSite === "B" ? "show-mobile" : "hide-mobile"}`}>

                        <h4 className="pane-header only-desktop">{locationBName.toUpperCase() || "SITE B"}</h4>

                        {compareResult ? renderTabContent(compareResult, analyzedCoordsB, locationBName, false) : <div className="empty-results">Waiting for selection...</div>}

                      </div>

                    </div>

                  )}

                </div>

              </>

            ) : (

              /* This displays when the page is freshly opened and no analysis has run */

              <div className="welcome-placeholder">

                <div className="placeholder-content">

                    <span className="placeholder-icon">üåç</span>

                    <h3>Ready for Analysis</h3>

                    <p>Select a location on the map or search above to begin geospatial synthesis.</p>

                </div>

              </div>

            )}

          </section>



        {/* Enhanced GeoGPT Component */}

        <GeoGPT 

          isOpen={isGptOpen}

          onClose={setIsGptOpen}

          currentData={result}

          locationName={locationAName}

          compareData={compareResult}

        />

      </main>



      {(showNearby || showNearbyB) && (

          <div className="modal-overlay" onClick={() => { setShowNearby(false); setShowNearbyB(false); }}>

            <div className="modal-card" onClick={(e) => e.stopPropagation()}>

              <div className="modal-header">

                <h3>Nearby Amenities ({showNearbyB ? locationBName : locationAName})</h3>

                <button className="modal-close" onClick={() => { setShowNearby(false); setShowNearbyB(false); }}>‚úñ</button>

              </div>

              <div className="modal-body">

                {(() => {

                  const data = showNearbyB ? nearbyDataB : nearbyData;

                  if (!data?.places?.length) return <div className="nearby-empty">No mapped amenities within 1.5 km.</div>;

                  

                  const schools = data.places.filter(p => p.type === "school");

                  const hospitals = data.places.filter(p => p.type === "hospital");

                  const colleges = data.places.filter(p => p.type === "college" || p.type === "university");

                  const markets = data.places.filter(p => p.type === "market");

                  const petrolBunks = data.places.filter(p => p.type === "petrol_bunk");

                  const accessCities = data.places.filter(p => p.type === "access_city");

                  const transit = data.places.filter(p => p.type === "transit");



                  // Display all categories including new ones

                  const allCategories = [

                    { title: "üè´ Schools", items: schools },

                    { title: "üè• Hospitals", items: hospitals },

                    { title: "üéì Colleges & Universities", items: colleges },

                    { title: "üõí Markets & Shopping", items: markets },

                    { title: "‚õΩ Petrol Bunks", items: petrolBunks },

                    { title: "üèôÔ∏è Access Cities", items: accessCities },

                    { title: "üöå Transit", items: transit }

                  ].filter(cat => cat.items.length > 0); // Only show categories with items



                  const Section = ({ title, items }) => (

                    <div className="nearby-section">

                      <h4>{title} ({items.length})</h4>

                      {items.length ? (

                        items.map((p, i) => (

                          <div key={i} className="nearby-item">

                            <span className="nearby-name">{p.name}</span>

                            <span className="nearby-distance">{p.distance_km} km</span>

                          </div>

                        ))

                      ) : (

                        <div className="nearby-empty">No nearby {title.toLowerCase()} found.</div>

                      )}

                    </div>

                  );



                  return (

                    <>

                      {allCategories.map((category, index) => (

                        <Section key={index} title={category.title} items={category.items} />

                      ))}

                    </>

                  );

                })()}

              </div>

            </div>

          </div>

        

      )}

    </div>

  );

}

